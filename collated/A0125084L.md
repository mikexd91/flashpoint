# A0125084L
###### main\java\exception\NoFileNameException.java
``` java
package main.java.exception;

/**
 * This class models a customized exception object to handle exception
 * caused by an absence of file name
 * @author Hou Bo Wen
 *
 */
public class NoFileNameException extends Exception{

	/**
	 * Constructs a NoFileNameException with the specified detail message.
	 * @param message The detail message
	 */
	public NoFileNameException(String message) {
		super(message);
	}
}
```
###### main\java\exception\NoFileNameException.java
``` java

```
###### main\java\Log\CustomFormatter.java
``` java
package main.java.Log;

import java.util.Date;
import java.util.logging.Formatter;
import java.util.logging.LogRecord;

public class CustomFormatter extends Formatter{

	@Override
	public String format(LogRecord record) {
		StringBuilder stringBuilder = new StringBuilder();
		
		stringBuilder.append(record.getLevel());
		stringBuilder.append(": ");
		stringBuilder.append(record.getMessage());
		stringBuilder.append(" [");
		stringBuilder.append(new Date(record.getMillis()));
		stringBuilder.append("]\r\n");
		
		return stringBuilder.toString();
	}
}
```
###### main\java\Log\CustomFormatter.java
``` java

```
###### main\java\Log\EventLog.java
``` java
package main.java.Log;
import java.io.IOException;
import java.util.logging.FileHandler;
import java.util.logging.Logger;

public class EventLog {

	Logger logger;
	FileHandler fileHandler;
	CustomFormatter formatter;
	
	public EventLog() {
	
		logger = Logger.getLogger("FlashPointLogger");
		try {
			fileHandler = new FileHandler("Eventlog.log");
			formatter = new CustomFormatter();
			fileHandler.setFormatter(formatter);
			logger.addHandler(fileHandler);
			logger.setUseParentHandlers(false);
		} catch (SecurityException | IOException e) {
			System.err.println("Error creating FileHandler");
		}
	}
	
	public Logger getLogger() {
		return logger;
	}
}
```
###### main\java\Log\EventLog.java
``` java

```
###### main\java\storage\CompletedTaskPermStorage.java
``` java
package main.java.storage;

import java.io.IOException;

/**
 * This class stores and modifies all completed tasks in the completed tasks file
 * @author Hou Bo Wen
 *
 */
public class CompletedTaskPermStorage extends PermStorage{

	/**
	 * Creates a CompletedTaskPermStorage instance
	 * @throws IOException If an I/O error occurs
	 */
	public CompletedTaskPermStorage() throws IOException {
		super();
	}
}
```
###### main\java\storage\CompletedTaskPermStorage.java
``` java

```
###### main\java\storage\CompletedTaskTempStorage.java
``` java
package main.java.storage;

import java.io.IOException;

/**
 * This class stores and modifies all completed tasks in the temporary tasks list
 * @author Hou Bo Wen
 *
 */
public class CompletedTaskTempStorage extends TempStorage{

	/**
	 * Creates a CompletedTaskTempStorage instance
	 * @throws IOException If an I/O error occurs
	 */
	public CompletedTaskTempStorage() throws IOException {
		super(new CompletedTaskPermStorage());
	}
}
```
###### main\java\storage\CompletedTaskTempStorage.java
``` java

```
###### main\java\storage\DirectoryController.java
``` java
package main.java.storage;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException; 

/**
 * Contains methods to read and write to a file, which stores
 * the path of the current working directory.
 * @author Hou Bo Wen
 *
 */
public class DirectoryController {
	
	private static final String ERROR_CREATE_FILE = "Cannot create directory file";
	private static final String ERROR_CREATE_STREAM = "Cannot create streams for directory file";
	private static final String ERROR_READ_FROM_FILE = "Error reading from directory file";
	private static final String ERROR_WRITE_TO_FILE = "Error writing to directory file";
	private static final String ERROR_CLEAR_FILE = "Cannot clear file";
	
	private BufferedReader bufferedReader;
	private BufferedWriter bufferedWriter;
	private File directoryFile;
	private FileWriter fileWriter;
	private String taskFilePath;

	/**
	 * Creates a DirectoryController instance
	 */
	public DirectoryController() {
		
	}
	
	/**
	 * Creates a DirectoryController instance
	 * @param taskFileName The name of the task file 
	 * @param dirFileName The name of the directory file
	 * @throws IOException If an I/O error occurs
	 */
	public DirectoryController(String taskFileName, String dirFileName) throws IOException {
		initialiseFileDirectory(taskFileName, dirFileName);
	}

	/**
	 * Returns the path of the task file in the current working directory
	 * @return The path of the task file in the current working directory
	 */
	public String getTaskFilePath() {
		return taskFilePath;
	}

	/**
	 * Updates the new path of where the task file is stored
	 * @throws IOException If an I/O error occurs
	 */
	public void updateDirectory(String path) throws IOException {	
		clearDirectoryFile();
		writeDirectory(path);
	}
	
	/*
	 * Creates a file to store the path of the task file
	 */
	private void initialiseFileDirectory(String taskFileName, String dirFileName) throws IOException {
		directoryFile = new File(dirFileName);

		if (!directoryFile.exists()) {
			try {
				directoryFile.createNewFile();
			} catch (IOException e) {
				throw new IOException(ERROR_CREATE_FILE);
			}
		}

		try {
			bufferedReader = new BufferedReader(new FileReader(directoryFile));
			bufferedWriter = new BufferedWriter(new FileWriter(directoryFile, true));
		} catch (IOException e) {
			throw new IOException(ERROR_CREATE_STREAM);
		}

		String lineRead;
		
		try {
			if ((lineRead = bufferedReader.readLine()) != null) {
				taskFilePath = lineRead;
			} else {
				taskFilePath = new File("").getAbsolutePath() + "\\" + taskFileName;
			}
		} catch (IOException e) {
			throw new IOException(ERROR_READ_FROM_FILE);
		}
	}
	
	/*
	 * Writes the path of the task file to the directory file
	 */
	private void writeDirectory(String dir) throws IOException {
		
		try {
			bufferedWriter.write(dir);
			bufferedWriter.flush();
		} catch (IOException e) {
			throw new IOException(ERROR_WRITE_TO_FILE);
		}
	}

	/*
	 * Clears the directory file
	 */
	private void clearDirectoryFile() throws IOException {
		
		try {
			fileWriter = new FileWriter(directoryFile);
			fileWriter.close();
		} catch (IOException e) {
			throw new IOException(ERROR_CLEAR_FILE);
		}
	}
}
```
###### main\java\storage\DirectoryController.java
``` java

```
###### main\java\storage\PendingTaskPermStorage.java
``` java
package main.java.storage;

import java.io.IOException;

/**
 * This class stores and modifies all pending tasks in the pending tasks file
 * @author Hou Bo Wen
 *
 */
public class PendingTaskPermStorage extends PermStorage{
	
	/**
	 * Creates a PendingTaskPermStorage instance
	 * @throws IOException If an I/O error occurs
	 */
	public PendingTaskPermStorage() throws IOException {
		super(new DirectoryController("Upcoming Tasks.txt", "Directory Info.txt"));
	}
}
```
###### main\java\storage\PendingTaskPermStorage.java
``` java

```
###### main\java\storage\PendingTaskTempStorage.java
``` java
package main.java.storage;

import java.io.IOException;

/**
 * This class stores and modifies all pending tasks in the pending tasks list
 * @author Bowen
 *
 */
public class PendingTaskTempStorage extends TempStorage{
	
	/**
	 * Creates a PendingTaskTempStorage instance
	 * @throws IOException If an I/O error occurs
	 */
	public PendingTaskTempStorage() throws IOException {
		super(new PendingTaskPermStorage());
	}
}
```
###### main\java\storage\PendingTaskTempStorage.java
``` java

```
###### main\java\storage\PermStorage.java
``` java
package main.java.storage;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
 
import com.google.gson.Gson;

import main.java.data.Task;
import main.java.exception.NoFileNameException;

/**
 * Contains methods that read and write tasks to the task file.
 * @author Hou Bo Wen
 *
 */
public class PermStorage {

	private static final String ERROR_COPY = "Error copying file";
	private static final String ERROR_WRITE_TO_FILE = "Error writing to task file.";
	private static final String ERROR_READ_FROM_FILE = "Error reading from task file.";
	private static final String ERROR_READ_WHILE_DELETE = "Error reading from task file while deleting.";
	private static final String ERROR_CLEAR_FILE = "Cannot clear task file";
	private static final String ERROR_CREATE_FILE = "Cannot create task file";
	private static final String ERROR_CREATE_STREAM = "Cannot create streams for task file";
	private static final String ERROR_REOPEN_STREAM = "Cannot reopen streams for task file";	
	private static final String FILE_NAME = "\\Completed Tasks.txt";
	
	private BufferedReader bufferedReader;
	private BufferedWriter bufferedWriter;
	private DirectoryController dirController;
	private File taskFile;
	private FileWriter fileWriter;
	private Gson gson;
	private ArrayList<Task> taskList;

	/**
	 * Creates a PermStorage instance 
	 * @throws IOException If an I/O error occurs
	 */
	public PermStorage() throws IOException {
		initialiseFile(new File("").getAbsolutePath() + FILE_NAME);
		gson = new Gson();
		taskList = new ArrayList<Task>();
	}
	
	/**
	 * Creates a PermStorage instance
	 * @param dirController The directoryController to be linked to
	 * @throws IOException If an I/O error occurs
	 */
	public PermStorage(DirectoryController dirController) throws IOException {
		this.dirController = dirController;
		initialiseFile(dirController.getTaskFilePath());
		gson = new Gson();
		taskList = new ArrayList<Task>();
	}
	
	/**
	 * Changes the working directory to the given path
	 * @param path The path of the file in the new working directory
	 * @throws IOException If an I/O error occurs
	 */
	public void moveToLocation(String path) throws IOException {
		File newFile = new File(path);
		Files.copy(taskFile.toPath(), newFile.toPath(), StandardCopyOption.REPLACE_EXISTING);
		taskFile = newFile;
		reopenStream();
		dirController.updateDirectory(path);
	}
	
	/**
	 * Loads the file based on the given path 
	 * @param path The path of the file to be loaded
	 * @throws IOException If an I/O error occurs
	 */ 
	public void loadFromFile(String path) throws IOException {
		taskFile = new File(path);
		reopenStream();
		dirController.updateDirectory(path);
		System.out.println(path);
	}
	
	/**
	 * Makes a copy of the task file in the given path
	 * @param path The path of the file to be saved in
	 * @throws IOException If an I/O error occurs
	 * @throws NoFileNameException If no file name is specified in the path
	 */
	public void saveToLocation(String path) throws IOException {
	
		File newFile = new File(path);
		
		try {
			Files.copy(taskFile.toPath(), newFile.toPath(), StandardCopyOption.REPLACE_EXISTING);
		} catch (IOException e) {
			throw new IOException(ERROR_COPY);
		}
	}
	
	/**
	 * Writes the given task to the task file
	 * @param task The task to be written
	 * @throws IOException If an I/O error occurs
	 */
	public void writeToFile(Task task) throws IOException {

		try {
			bufferedWriter.write(gson.toJson(task));
			bufferedWriter.newLine();
			bufferedWriter.flush();
		} catch (IOException e) {
			throw new IOException(ERROR_WRITE_TO_FILE);
		}
	}
	
	/**
	 * Replaces the task at the given line number with the editedTask task
	 * @param lineNum The line number of the task to be edited
	 * @param editedTask The task that has been edited
	 * @throws IOException If an I/O error occurs
	 */
	public void editToFile(int lineNum, Task editedTask) throws IOException {
		deleteFromFile(lineNum);
		writeToFile(editedTask);
	}
	
	/**
	 * Returns the list of tasks from the task file
	 * @return The list of tasks from the task file
	 * @throws IOException If an I/O error occurs
	 */
	public ArrayList<Task> readFromFile() throws IOException {
		String lineRead;
		taskList.clear();
		
		try {
			while ((lineRead = bufferedReader.readLine()) != null) {
				Task taskRead = gson.fromJson(lineRead, Task.class);
				if (taskRead != null) {
					taskList.add(taskRead);
				}
			}
		} catch (IOException e) {
			throw new IOException(ERROR_READ_FROM_FILE);
		}
		reopenStream();

		return taskList;
	}
	
	/**
	 * Removes the task at the give line number in the task file
	 * @param lineNum The line number of the task to be deleted
	 * @throws IOException If an I/O error occurs
	 */
	public void deleteFromFile(int lineNum) throws IOException {
		
		ArrayList<Task> tempTaskList = new ArrayList<Task>();
		int currentLineNum = 0;   //first line is of index 0
		String lineRead;
		
		try {
			while ((lineRead = bufferedReader.readLine()) != null) {
				if (currentLineNum != lineNum) {
					Task taskRead = gson.fromJson(lineRead, Task.class);
					tempTaskList.add(taskRead);
				}
				currentLineNum++;
			}
		} catch (IOException e) {
			throw new IOException(ERROR_READ_WHILE_DELETE);
		}
		
		clearFile();

		for (int i = 0; i < tempTaskList.size(); i++) {
			writeToFile(tempTaskList.get(i));
		}	
		
		reopenStream();
	}
	
	/**
	 * Clears the file of all tasks
	 * @throws IOException If an I/O error occurs
	 */
	public void clearFile() throws IOException {
		
		try {
			fileWriter = new FileWriter(taskFile);
			fileWriter.close();
		} catch (IOException e) {
			throw new IOException(ERROR_CLEAR_FILE);
		}
	}

	/**
	 * Copies the given list of tasks to the file, overwriting any content in the file 
	 * @param list The list of tasks to be copied to the file
	 * @throws IOException If an I/O error occurs
	 */
	public void copyAllToFile(ArrayList<Task> list) throws IOException {
		
		clearFile();
		for(int i = 0; i < list.size(); i++) {
			writeToFile(list.get(i));
		}
	}
	
	/*
	 * Creates the task file and streams for reading and writing
	 */
	private void initialiseFile(String filePath) throws IOException {
		
		taskFile = new File(filePath);
		
		try {
			if (!taskFile.exists()) {
				taskFile.createNewFile();			
			}
		} catch (IOException e) {
			throw new IOException(ERROR_CREATE_FILE);
		}
		
		try {
			bufferedReader = new BufferedReader(new FileReader(taskFile));
			bufferedWriter = new BufferedWriter(new FileWriter(taskFile, true));
		} catch (IOException e) {
			throw new IOException(ERROR_CREATE_STREAM);
		}
	}

	/*
	 * Creates new streams to allow reading and writing from the top of the file
	 */
	private void reopenStream() throws IOException {
		
		try {
			bufferedReader.close();
			bufferedWriter.close();
			bufferedReader = new BufferedReader(new FileReader(taskFile));	
			bufferedWriter = new BufferedWriter(new FileWriter(taskFile, true));
		} catch (IOException e) {
			throw new IOException(ERROR_REOPEN_STREAM);
		}
	}
}
```
###### main\java\storage\PermStorage.java
``` java

```
###### main\java\storage\PriorityComparator.java
``` java
package main.java.storage;

import java.util.Comparator;

import main.java.data.Task;
 /**
  * A Comparator for Task objects that can sort tasks based on their priority
  * @author Hou Bo Wen
  *
  */
public class PriorityComparator implements Comparator<Task>{

	/**
	 * 
	 */
	@Override
	public int compare(Task task1, Task task2) {

		if (task1.getPriority().equals(task2.getPriority())) {
			return task1.getTask().compareTo(task2.getTask());
		}
		else {
			return task1.getPriority().compareTo(task2.getPriority());
		}
	}
}
```
###### main\java\storage\PriorityComparator.java
``` java

```
###### main\java\storage\StorageController.java
``` java
package main.java.storage;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import main.java.data.Task;
import main.java.enumeration.PriorityLevel;
import main.java.enumeration.TaskStatus;
 
/**
 * Contains methods that modifies the tasks contents in the Pending and Completed tasks storages
 * @author Hou Bo Wen
 *
 */
public class StorageController {

	private static final int TASK_PENDING = 0;
	private static final int TASK_COMPLETED = 1;
	private static final int TASK_BOTH = 2;
	
	private PendingTaskTempStorage pendingTemp;
	private CompletedTaskTempStorage completedTemp;
	private int lastAction;

	/**
	 * Creates a StorageController instance
	 * @throws IOException If an I/O error occurs
	 */
	public StorageController() throws IOException {	
		pendingTemp = new PendingTaskTempStorage();
		completedTemp = new CompletedTaskTempStorage();
	}

	/**
	 * Adds a new task
	 * @param task The task to be added
	 * @throws IOException If an I/O error occurs
	 */
	public void addTask(Task task) throws IOException {
		assert task != null;
		
		task.setLastModified(true);
		pendingTemp.addToTemp(task);
		lastAction = TASK_PENDING;
	}
	
	/**
	 * Returns the list of pending tasks
	 * @return The list of pending tasks
	 */
	public ArrayList<Task> displayPendingTasks() {
		return pendingTemp.displayTemp();
	}
	
	/**
	 * Returns the list of completed tasks
	 * @return The list of completed tasks
	 */
	public ArrayList<Task> displayCompletedTasks() {
		return completedTemp.displayTemp();
	}
	
	/**
	 * Edits the existing pending task to another specified task
	 * @param taskToEdit The existing task to edit
	 * @param editedTask The task that has been edited
	 * @throws IOException If an I/O error occurs
	 */
	public void editPendingTask(Task taskToEdit, Task editedTask) throws IOException {
		assert taskToEdit != null;
		assert editedTask != null;
		
		editedTask.setLastModified(true);
		pendingTemp.editToTemp(taskToEdit, editedTask);
		lastAction = TASK_PENDING;
	}
	
	/**
	 * Edits the existing completed task to another specified task
	 * @param taskToEdit The existing task to edit
	 * @param editedTask The task that has been edited
	 * @throws IOException If an I/O error occurs
	 */
	public void editCompletedTask(Task taskToEdit, Task editedTask) throws IOException {
		assert taskToEdit != null;
		assert editedTask != null;
		
		editedTask.setLastModified(true);
		completedTemp.editToTemp(taskToEdit, editedTask);
		lastAction = TASK_COMPLETED;
	}
	
	/**
	 * Removes a pending task
	 * @param task The task to be deleted
	 * @throws IOException If an I/O error occurs
	 */
	public void deletePendingTask(Task task) throws IOException {
		assert task != null;
		
		pendingTemp.deleteFromTemp(task);
		lastAction = TASK_PENDING;
	}
	
	/**
	 * Removes a completed task
	 * @param task The task to be deleted
	 * @throws IOException If an I/O error occurs
	 */
	public void deleteCompletedTask(Task task) throws IOException {
		assert task != null;
		
		completedTemp.deleteFromTemp(task);
		lastAction = TASK_COMPLETED;
	}
	
	/**
	 * Clears all pending tasks
	 * @throws IOException If an I/O error occurs
	 */
	public void clearAllPendingTasks() throws IOException {	
		pendingTemp.clearAll();
		lastAction = TASK_PENDING;
	}
	
	/**
	 * Clears all upcoming tasks
	 * @throws IOException If an I/O error occurs
	 */
	public void clearUpcomingTasks() throws IOException {
		pendingTemp.clearUpcoming();
		lastAction = TASK_PENDING;
	}
	
	/**
	 * Clears all floating tasks
	 * @throws IOException If an I/O error occurs
	 */
	public void clearFloatingTasks() throws IOException {
		pendingTemp.clearFloating();
		lastAction = TASK_PENDING;
	}
	
	/**
	 * Clears all overdue tasks
	 * @throws IOException If an I/O error occurs
	 */
	public void clearOverdueTasks() throws IOException {
		pendingTemp.clearOverdue();
		lastAction = TASK_PENDING;
	}
	
	/**
	 * Clears all completed tasks
	 * @throws IOException If an I/O error occurs
	 */
	public void clearCompletedTasks() throws IOException {		
		completedTemp.clearAll();
		lastAction = TASK_COMPLETED;
	}
	
	/**
	 * Sorts the pending tasks by their task name
	 * @throws IOException If an I/O error occurs
	 */
	public void sortPendingByTaskName() throws IOException {
		pendingTemp.sortByTaskName();
		lastAction = TASK_PENDING;
	}
	
	/**
	 * Sorts the pending tasks by their starting time or deadline
	 * @throws IOException If an I/O error occurs
	 */
	public void sortPendingByTime() throws IOException {
		pendingTemp.sortByTime();
		lastAction = TASK_PENDING;
	}
	
	/**
	 * Sorts the pending tasks by their priority
	 * @throws IOException If an I/O error occurs
	 */
	public void sortPendingByPriority() throws IOException {
		pendingTemp.sortByPriority();
		lastAction = TASK_PENDING;
	}
	
	/**
	 * Sorts the completed tasks by their task name
	 * @throws IOException If an I/O error occurs
	 */
	public void sortCompletedByTaskName() throws IOException {
		completedTemp.sortByTaskName();
		lastAction = TASK_COMPLETED;
	}
	
	/**
	 * Sorts the completed tasks by their starting time or deadline
	 * @throws IOException If an I/O error occurs
	 */
	public void sortCompletedByTime() throws IOException {
		completedTemp.sortByTime();
		lastAction = TASK_COMPLETED;
	}
	
	/**
	 * Sorts the completed tasks by their priority
	 * @throws IOException If an I/O error occurs
	 */
	public void sortCompletedByPriority() throws IOException {
		completedTemp.sortByPriority();
		lastAction = TASK_COMPLETED;
	}
	
	/**
	 * Marks a task as completed and moves it to the completed tasks storage
	 * @param task The task to be marked
	 * @throws IOException If an I/O error occurs
	 */
	public void moveTaskToComplete(Task task) throws IOException {
		assert task != null;
		
		pendingTemp.deleteFromTemp(task);
		
		Task taskCopy = new Task(task.getTask(), task.getTime(), task.getPriority(), 
				task.getType(), TaskStatus.COMPLETED);
		
		taskCopy.setLastModified(true);	
		completedTemp.addToTemp(taskCopy);	
		lastAction = TASK_BOTH;
	}
	
	/**
	 * Unmarks a task and moves it back to the pending tasks storage
	 * @param task The task to be unmarked
	 * @throws IOException If an I/O error occurs
	 */
	public void moveTaskToPending(Task task) throws IOException {
		assert task != null;
		
		completedTemp.deleteFromTemp(task);
		
		Task taskCopy = new Task(task.getTask(), task.getTime(), task.getPriority(), 
				task.getType(), determineStatus(task.getTime()));
		
		taskCopy.setLastModified(true);
		pendingTemp.addToTemp(taskCopy);		
		lastAction = TASK_BOTH;
	}
	
	/**
	 * Undoes the previous command
	 * @throws IOException If an I/O error occurs
	 */
	public void undo() throws IOException {
		if (lastAction == TASK_PENDING) {
			pendingTemp.undoPrevious();
		}
		else if (lastAction == TASK_COMPLETED) {
			completedTemp.undoPrevious();
		}
		else if (lastAction == TASK_BOTH) {
			pendingTemp.undoPrevious();
			completedTemp.undoPrevious();
		}
	}
	
	/**
	 * Negates the previous undo command
	 * @throws IOException If an I/O error occurs
	 */
	public void redo() throws IOException {
		if (lastAction == TASK_PENDING) {
			pendingTemp.redoPrevious();
		}
		else if (lastAction == TASK_COMPLETED) {
			completedTemp.redoPrevious();
		}
		else if (lastAction == TASK_BOTH) {
			pendingTemp.redoPrevious();
			completedTemp.redoPrevious();
		}
	}
	
	/**
	 * Returns a list of pending tasks that start or are ongoing on the given date
	 * @param date The date for the tasks to be shown
	 * @return The list of pending tasks that start or are ongoing on the given date
	 */
	public ArrayList<Task> showAllPendingByDate(Date date) {
		return pendingTemp.showAllByDate(date);
	}
	
	/**
	 * Returns a list of pending tasks that have the given priority level
	 * @param priority The priority for the tasks to be shown
	 * @return The list of pending tasks that have the given priority level
	 */
	public ArrayList<Task> showAllPendingByPriority(PriorityLevel priority) {
		return pendingTemp.showAllByPriority(priority);
	}
	
	/**
	 * Returns a list of completed tasks that started or were ongoing on the given date
	 * @param date The date for the tasks to be shown
	 * @return The list of completed tasks that started or were ongoing on the given date
	 */
	public ArrayList<Task> showAllCompletedByDate(Date date) {
		return completedTemp.showAllByDate(date);
	}
	
	/**
	 * Returns a list of completed tasks that have the given priority level
	 * @param priority The priority for the tasks to be shown
	 * @return The list of completed tasks that have the given priority level
	 */
	public ArrayList<Task> showAllCompletedByPriority(PriorityLevel priority) {
		return completedTemp.showAllByPriority(priority);
	}
	
	/**
	 * Returns a list of pending tasks that matches the given string 
	 * @param stringToSearch The string to be searched
	 * @return The list of pending tasks that matches the given string 
	 */
	public ArrayList<Task> searchMatchPending(String stringToSearch) {
		return pendingTemp.searchMatch(stringToSearch);
	}
	
	/**
	 * Returns a list of completed tasks that matches the given string 
	 * @param stringToSearch The string to be searched
	 * @return The list of completed tasks that matches the given string 
	 */
	public ArrayList<Task> searchMatchCompleted(String stringToSearch) {
		return completedTemp.searchMatch(stringToSearch);
	}
	
	/**
	 * Changes the current working directory to the given path
	 * @param path The path of the file in the new working directory
	 * @throws IOException If an I/O error occurs
	 */
	public void moveToLocation(String path) throws IOException {
		assert path != null;
		
		pendingTemp.moveToLocation(path);
	}

	/**
	 * Loads and retrieves the tasks from the file based on the given path
	 * @param path The path of the file to be loaded
	 * @throws IOException If an I/O error occurs
	 */
	public void loadFromFile(String path) throws IOException {
		assert path != null;
		
		pendingTemp.loadFromFile(path);
	}
	
	/**
	 * Makes a copy of the task file in the given path
	 * @param path The path of the file to be saved in
	 * @throws Exception If no file name is specified in the path
	 */
	public void saveToLocation(String path) throws IOException {
		assert path != null;
		
		pendingTemp.saveToLocation(path);
	}
	
	/**
	 * Returns a list of all overdue tasks relative to the given date
	 * @param date The date for the tasks to be checked overdue against
	 * @return The list of all overdue tasks relative to the given date
	 * @throws IOException If an I/O error occurs
	 */
	public ArrayList<Task> checkOverdue(Date date) throws IOException {
		return pendingTemp.checkOverdue(date);
	}
	
	/*
	 * Determines the status of a task based on the given dates field 
	 */
	private TaskStatus determineStatus(List<Date> dates) {
		int size = dates.size();
		
		if (size == 0) {
			return TaskStatus.FLOATING;
		}
		else if (dates.get(size - 1).before(new Date())) {
			return TaskStatus.OVERDUE;
		}
		else {
			return TaskStatus.UPCOMING;
		}
	}
}
```
###### main\java\storage\StorageController.java
``` java

```
###### main\java\storage\StorageTest.java
``` java
package main.java.storage;

import static org.junit.Assert.*;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import org.junit.Test;

import main.java.data.Task;
import main.java.enumeration.PriorityLevel;
import main.java.enumeration.TaskStatus;
import main.java.enumeration.TaskType;

/**
 * This class contains of unit tests for the storage component
 * Tasks passed by the Logic component is ensured not to be null
 * @author Hou Bo Wen
 *
 */
public class StorageTest {
	
	private static final String ERROR_ADD_TASK = "Error adding task";
	private static final String ERROR_DELETE_TASK = "Error deleting task";
	private static final String ERROR_SORT = "Error while sorting";
	private static final String ERROR_UNDO = "Error while undoing";
	private static final String ERROR_REDO = "Error while redoing";
	private static final String ERROR_MARK_TASK = "Error while marking task";
	private static final String ERROR_UNMARK_TASK = "Error while unmarking task";
	private static final String ERROR_SAVE = "Error saving to location";

	private StorageController storageController;
	private Task pendingTask0, pendingTask1, pendingTask2, completedTask0, completedTask1, completedTask2;
	private List<Date> dateList;

	public void initialise() throws IOException {
		storageController = new StorageController();
		
		dateList = new ArrayList<Date>();
		  
		pendingTask0 = new Task("do homework", dateList, PriorityLevel.HIGH, TaskType.EVENT, TaskStatus.UPCOMING);
		pendingTask1 = new Task("eat dinner", dateList,  PriorityLevel.MEDIUM, TaskType.EVENT, TaskStatus.FLOATING);
		pendingTask2 = new Task("meet friends", dateList,  PriorityLevel.LOW, TaskType.EVENT, TaskStatus.OVERDUE);
		completedTask0 = new Task("play soccer", dateList,  PriorityLevel.HIGH, TaskType.EVENT, TaskStatus.COMPLETED);
		completedTask1 = new Task("submit homework", dateList,  PriorityLevel.MEDIUM, TaskType.EVENT, TaskStatus.COMPLETED);
		completedTask2 = new Task("watch movie", dateList,  PriorityLevel.LOW, TaskType.EVENT, TaskStatus.COMPLETED);
	}
	 
	/*
	 * Checks if two tasks are the same
	 * Returns true if all fields are the same, else return false
	 */
	private boolean isTaskEqual(Task task1, Task task2) {
		boolean isSameName = task1.getTask().equals(task2.getTask());
		boolean isSameTime = task1.getTime().equals(task2.getTime());
		boolean isSamePriority = task1.getPriority().equals(task2.getPriority());
		boolean isSameType = task1.getType().equals(task2.getType());
		boolean isSameStatus = task1.getStatus().equals(task2.getStatus());
		
		if (isSameName && isSameTime && isSamePriority && isSameType && isSameStatus) {
			return true;
		}
		else {
			return false;
		}
	}
		
	/*
	 * Tests the add function
	 */
	@Test
	public void testAddTask() throws IOException {			
		initialise();
		
		try {
			//Add pending task when the list is empty
			storageController.addTask(pendingTask0);		
			assertTrue(isTaskEqual(pendingTask0, storageController.displayPendingTasks().get(0)));

			//Add pending task when list is not empty
			storageController.addTask(pendingTask1);
			assertTrue(isTaskEqual(pendingTask1, storageController.displayPendingTasks().get(1)));

			//Add completed task when list is empty
			storageController.addTask(completedTask0);
			storageController.moveTaskToComplete(completedTask0);
			assertTrue(isTaskEqual(completedTask0, storageController.displayCompletedTasks().get(0)));
			
			//Add completed task when list is not empty
			storageController.addTask(completedTask1);
			storageController.moveTaskToComplete(completedTask1);
			assertTrue(isTaskEqual(completedTask1, storageController.displayCompletedTasks().get(1)));
			
			storageController.clearAllPendingTasks();
			storageController.clearCompletedTasks();
	
		} catch (IOException e) {
			System.err.println(ERROR_ADD_TASK);
		}
	}

	/*
	 * Tests the edit function
	 */
	@Test
	public void testEditTask() throws IOException {
		initialise();
		
		//Edit pending task when the list has only 1 task
		storageController.addTask(pendingTask0);
		storageController.editPendingTask(pendingTask0, pendingTask1);
		assertTrue(isTaskEqual(pendingTask1, storageController.displayPendingTasks().get(0)));
		
		//Edit pending task when the list has more than 1 tasks
		storageController.addTask(pendingTask0);
		storageController.editPendingTask(pendingTask0, pendingTask2);
		assertTrue(isTaskEqual(pendingTask2, storageController.displayPendingTasks().get(1)));
		
		//Edit completed task when the list has only 1 task
		storageController.addTask(completedTask0);
		storageController.moveTaskToComplete(completedTask0);
		storageController.editCompletedTask(completedTask0, completedTask1);
		assertTrue(isTaskEqual(completedTask1, storageController.displayCompletedTasks().get(0)));
		
		//Edit completed task when the list has more than 1 tasks
		storageController.addTask(completedTask0);
		storageController.moveTaskToComplete(completedTask0);
		storageController.editCompletedTask(completedTask0, completedTask2);
		assertTrue(isTaskEqual(completedTask2, storageController.displayCompletedTasks().get(1)));
		
		storageController.clearAllPendingTasks();
		storageController.clearCompletedTasks();
	}

	/*
	 * Tests the delete function
	 */
	@Test
	public void testDeleteTask() {		
	
		try {
			initialise();
			
			//Delete pending task when the list has only 1 task
			storageController.addTask(pendingTask0);
			assertTrue(storageController.displayPendingTasks().size() == 1);
			storageController.deletePendingTask(pendingTask0);
			assertTrue(storageController.displayPendingTasks().size() == 0);

			//Delete pending task when the list has more than 1 task
			storageController.addTask(pendingTask0);
			storageController.addTask(pendingTask1);
			assertTrue(storageController.displayPendingTasks().size() == 2);
			storageController.deletePendingTask(pendingTask1);
			assertTrue(storageController.displayPendingTasks().size() == 1);
			assertTrue(isTaskEqual(pendingTask0, storageController.displayPendingTasks().get(0)));
	
			//Delete completed task when the list has only 1 task
			storageController.addTask(completedTask0);
			storageController.moveTaskToComplete(completedTask0);
			assertTrue(storageController.displayCompletedTasks().size() == 1);
			storageController.deleteCompletedTask(completedTask0);
			assertTrue(storageController.displayCompletedTasks().size() == 0);
			
			//Delete completed task when the list has more than 1 tasks
			storageController.addTask(completedTask0);
			storageController.addTask(completedTask1);
			storageController.moveTaskToComplete(completedTask0);
			storageController.moveTaskToComplete(completedTask1);
			assertTrue(storageController.displayCompletedTasks().size() == 2);
			storageController.deleteCompletedTask(completedTask1);
			assertTrue(storageController.displayCompletedTasks().size() == 1);
			assertTrue(isTaskEqual(completedTask0, storageController.displayCompletedTasks().get(0)));
			
			storageController.clearAllPendingTasks();
			storageController.clearCompletedTasks();
			
		} catch (IOException e) {
			System.err.println(ERROR_DELETE_TASK);
		}
	}

	/*
	 * Tests the sorting function
	 */
	@Test
	public void testSortByName() {
		ArrayList<Task> expectedList = new ArrayList<Task>();	

		try {
			initialise();
			
			expectedList.add(pendingTask0);
			expectedList.add(pendingTask1);
			expectedList.add(pendingTask2);	
			storageController.addTask(pendingTask2);
			storageController.addTask(pendingTask0);
			storageController.addTask(pendingTask1);
			storageController.sortPendingByTaskName();

			assertEquals(expectedList.get(0).getTask(), storageController.displayPendingTasks().get(0).getTask());
			assertEquals(expectedList.get(1).getTask(), storageController.displayPendingTasks().get(1).getTask());
			assertEquals(expectedList.get(2).getTask(), storageController.displayPendingTasks().get(2).getTask());

			storageController.clearAllPendingTasks();
			storageController.clearCompletedTasks();
		
		} catch (IOException e) {
			System.err.println(ERROR_SORT);
		}
	}

	/*
	 * Tests the undo function
	 */
	@Test
	public void testUndo() {

		try {
			initialise();
			
			//Tests undo with only 1 previous command
			storageController.addTask(pendingTask0);
			storageController.editPendingTask(pendingTask0, pendingTask1);
			storageController.undo();
			assertTrue(isTaskEqual(pendingTask0, storageController.displayPendingTasks().get(0)));

			//Tests undo with more than 1 previous command
			storageController.undo();
			assertTrue(storageController.displayPendingTasks().size() == 0);		
			
			storageController.clearAllPendingTasks();
			storageController.clearCompletedTasks();
			
		} catch (IOException e) {
			System.err.println(ERROR_UNDO);
		}
	}

	/*
	 * Tests the redo function
	 */
	@Test
	public void testRedo() {
	
		try {
			initialise();
			
			//Tests redo with only 1 previous undo command
			storageController.addTask(pendingTask0);
			storageController.editPendingTask(pendingTask0, pendingTask1);
			storageController.undo();
			assertTrue(isTaskEqual(pendingTask0, storageController.displayPendingTasks().get(0)));
			storageController.redo();
			assertTrue(isTaskEqual(pendingTask1, storageController.displayPendingTasks().get(0)));
		
			//Tests redo with more than 1 previous undo command
			storageController.undo();
			assertTrue(isTaskEqual(pendingTask0, storageController.displayPendingTasks().get(0)));
			storageController.redo();
			assertTrue(isTaskEqual(pendingTask1, storageController.displayPendingTasks().get(0)));
			
			storageController.clearAllPendingTasks();
			storageController.clearCompletedTasks();
			
		} catch (IOException e) {
			System.err.println(ERROR_REDO);
		}
		
	}
	
	/*
	 * Tests the mark function
	 */
	@Test
	public void testMoveTaskToComplete() {
		
		try {
			initialise();
			storageController.addTask(pendingTask0);
			storageController.moveTaskToComplete(pendingTask0);

			//Asserts that task has been marked as completed
			assertTrue(storageController.displayPendingTasks().size() == 0);
			assertTrue(storageController.displayCompletedTasks().size() == 1);
			assertEquals(pendingTask0.getTask(), storageController.displayCompletedTasks().get(0).getTask());
			assertEquals(pendingTask0.getTime(), storageController.displayCompletedTasks().get(0).getTime());
			assertEquals(pendingTask0.getPriority(), storageController.displayCompletedTasks().get(0).getPriority());
			assertEquals(pendingTask0.getType(), storageController.displayCompletedTasks().get(0).getType());
			assertEquals(TaskStatus.COMPLETED, storageController.displayCompletedTasks().get(0).getStatus());
			
			storageController.clearAllPendingTasks();
			storageController.clearCompletedTasks();
			
		} catch (IOException e) {
			System.err.println(ERROR_MARK_TASK);
		}
	}
	
	/*
	 * Tests the unmark function
	 */
	@Test
	public void testMoveTaskToPending() {
	
		try {
			initialise();
			storageController.addTask(pendingTask0);
			storageController.moveTaskToComplete(pendingTask0);
			
			//Asserts that task has been marked as completed
			assertTrue(storageController.displayPendingTasks().size() == 0);
			assertTrue(storageController.displayCompletedTasks().size() == 1);
			assertEquals(pendingTask0.getTask(), storageController.displayCompletedTasks().get(0).getTask());
			assertEquals(pendingTask0.getTime(), storageController.displayCompletedTasks().get(0).getTime());
			assertEquals(pendingTask0.getPriority(), storageController.displayCompletedTasks().get(0).getPriority());
			assertEquals(pendingTask0.getType(), storageController.displayCompletedTasks().get(0).getType());
			assertEquals(TaskStatus.COMPLETED, storageController.displayCompletedTasks().get(0).getStatus());
			
			storageController.moveTaskToPending(pendingTask0);
			
			//Asserts that task has been unmarked
			assertTrue(storageController.displayPendingTasks().size() == 1);
			assertTrue(storageController.displayCompletedTasks().size() == 0);
			assertEquals(pendingTask0.getTask(), storageController.displayPendingTasks().get(0).getTask());
			assertEquals(pendingTask0.getTime(), storageController.displayPendingTasks().get(0).getTime());
			assertEquals(pendingTask0.getPriority(), storageController.displayPendingTasks().get(0).getPriority());
			assertEquals(pendingTask0.getType(), storageController.displayPendingTasks().get(0).getType());
			assertEquals(TaskStatus.FLOATING, storageController.displayPendingTasks().get(0).getStatus());
		
			storageController.clearAllPendingTasks();
			storageController.clearCompletedTasks();
			
		} catch (IOException e) {
			System.err.println(ERROR_UNMARK_TASK);
		}	
	}
	
	/*
	 * Tests the save function
	 */
	@Test
	public void testSaveToLocation() {
		
		String pathCurrentDir = "test save file.txt";
		
		//Sections commented off as directories vary on different computers
//		String pathOtherDir = "C:\\Users\\Bowen\\Desktop\\test save.txt";
		
		try {
			initialise();
			
			//Tests saving file to the current directory
			File file = new File(pathCurrentDir);
			assertFalse(file.exists());
			storageController.saveToLocation(pathCurrentDir);
			assertTrue(file.exists());
	
			file.delete();
			
//			//Tests saving file to other directory
//			file = new File(pathOtherDir);
//			assertFalse(file.exists());
//			storageController.saveToLocation(pathOtherDir);
//			assertTrue(file.exists());
//			
//			file.delete();
			
		} catch (IOException e) {
			System.err.println(ERROR_SAVE);
		}
	}

}
```
###### main\java\storage\StorageTest.java
``` java

```
###### main\java\storage\TaskNameComparator.java
``` java
package main.java.storage;

import java.util.Comparator;

import main.java.data.Task;

/**
 * A Comparator for Task objects that can sort tasks based on their name
 * @author Hou Bo Wen
 *
 */
public class TaskNameComparator implements Comparator<Task>{

	@Override
	public int compare(Task task1, Task task2) {

		return task1.getTask().compareToIgnoreCase(task2.getTask());
	}
}
```
###### main\java\storage\TaskNameComparator.java
``` java

```
###### main\java\storage\TempStorage.java
``` java
package main.java.storage;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Date;
import java.util.Stack;

import org.ocpsoft.prettytime.shade.edu.emory.mathcs.backport.java.util.Collections;

import main.java.data.Task;
import main.java.enumeration.PriorityLevel;
import main.java.enumeration.TaskStatus;

/**
 * Contains methods that read and write tasks to a list before
 * passing the tasks to the permanent storage.
 * @author Hou Bo Wen
 *
 */
public class TempStorage {

	private static final int TASK_NOT_FOUND = -1;
	
	private boolean isPreviousUndo;
	private PermStorage permStorage;
	private String prevSearch;
	private Stack<ArrayList<Task>> undoStack;
	private Stack<ArrayList<Task>> redoStack;
	private Stack<ArrayList<Task>> searchHistory;
	private ArrayList<Task> taskList;

	/**
	 * Creates a TempStorage instance
	 */
	public TempStorage () {

	}

	/**
	 * Creates a TempStorage instance
	 * @param permStorage The permanent storage to be linked to, ie. pending or completed
	 * @throws IOException If an I/O error occurs
	 */
	public TempStorage(PermStorage permStorage) throws IOException {
		this.permStorage = permStorage;
		undoStack = new Stack<ArrayList<Task>>();
		taskList = new ArrayList<Task>(retrieveListFromFile());
		undoStack.push(new ArrayList<Task>(taskList));
		redoStack = new Stack<ArrayList<Task>>();
		
		searchHistory = new Stack<ArrayList<Task>>();
		searchHistory.push(taskList);
		prevSearch = "";
	}

	/**
	 * Adds a task to the tasks list
	 * @param task The task to be added
	 * @throws IOException If an I/O error occurs
	 */
	public void addToTemp(Task task) throws IOException {
		
		Task taskCopy = new Task(task.getTask(), task.getTime(), task.getPriority(), 
					task.getType(), task.getStatus());
		
		taskCopy.setLastModified(true);
		taskList.add(taskCopy);
		Collections.sort(taskList, new TimeComparator());
		undoStack.push(new ArrayList<Task>(taskList));
		permStorage.writeToFile(taskCopy);
		isPreviousUndo = false;
	}

	/**
	 * Returns a list containing all the tasks
	 * @return The list containing all the tasks
	 */
	public ArrayList<Task> displayTemp() {
		return taskList;
	}

	/**
	 * Replaces an existing taskToEdit task with the given editedTask task
	 * @param taskToEdit The existing task to edit
	 * @param editedTask The task that has been edited
	 * @throws IOException If an I/O error occurs
	 */
	public void editToTemp(Task taskToEdit, Task editedTask) throws IOException {
		int indexOfTaskToEdit = searchTemp(taskToEdit);
		
		Task editedTaskCopy = new Task(editedTask.getTask(), editedTask.getTime(), editedTask.getPriority(), 
				editedTask.getType(), editedTask.getStatus());
		
		editedTaskCopy.setLastModified(true);
		taskList.set(indexOfTaskToEdit, editedTaskCopy);
		Collections.sort(taskList, new TimeComparator());
		undoStack.push(new ArrayList<Task>(taskList));
		permStorage.editToFile(indexOfTaskToEdit, editedTaskCopy);
		isPreviousUndo = false;
	}

	/**
	 * Removes a task from the tasks list
	 * @param task The task to be deleted
	 * @throws IOException If an I/O error occurs
	 */
	public void deleteFromTemp(Task task) throws IOException {
		int indexOfTaskToDelete = searchTemp(task);
		taskList.remove(taskList.get(indexOfTaskToDelete));
		undoStack.push(new ArrayList<Task>(taskList));
		permStorage.deleteFromFile(indexOfTaskToDelete);
		isPreviousUndo = false;
	}

	/**
	 * Clears all tasks from the tasks list
	 * @throws IOException If an I/O error occurs
	 */
	public void clearAll() throws IOException {
		taskList.clear();
		undoStack.push(new ArrayList<Task>(taskList));
		permStorage.clearFile();
		isPreviousUndo = false;
	}
	
	/**
	 * Clears all upcoming tasks from the tasks list
	 * @throws IOException If an I/O error occurs
	 */
	public void clearUpcoming() throws IOException {
		
		for (int i = taskList.size() - 1; i >= 0; i--) {
			Task task = taskList.get(i);
			if (task.getStatus().equals(TaskStatus.UPCOMING)) {
				taskList.remove(i);
				permStorage.deleteFromFile(i);
			}
		}
		undoStack.push(new ArrayList<Task>(taskList));
		isPreviousUndo = false;
	}
	
	/**
	 * Clears all floating tasks from the tasks list
	 * @throws IOException If an I/O error occurs
	 */
	public void clearFloating() throws IOException {
		
		for (int i = taskList.size() - 1; i >= 0; i--) {
			Task task = taskList.get(i);
			if (task.getStatus().equals(TaskStatus.FLOATING)) {
				taskList.remove(i);
				permStorage.deleteFromFile(i);
			}
		}
		undoStack.push(new ArrayList<Task>(taskList));
		isPreviousUndo = false;
	}
	
	/**
	 * Clears all overdue tasks from the tasks list
	 * @throws IOException If an I/O error occurs
	 */
	public void clearOverdue() throws IOException {
		
		for (int i = taskList.size() - 1; i >= 0; i--) {
			Task task = taskList.get(i);
			if (task.getStatus().equals(TaskStatus.OVERDUE)) {
				taskList.remove(i);
				permStorage.deleteFromFile(i);
			}
		}
		undoStack.push(new ArrayList<Task>(taskList));
		isPreviousUndo = false;
	}

	/**
	 * Revert back to the previous state before a method is called
	 * @throws IOException If an I/O error occurs
	 */
	public void undoPrevious() throws IOException {
		if (undoStack.size() >= 2) {
			ArrayList<Task> currentState = new ArrayList<Task>(undoStack.pop());
			redoStack.push(currentState);
			taskList = new ArrayList<Task>(undoStack.peek());
			permStorage.copyAllToFile(taskList);
			isPreviousUndo = true;
		}
	}
	
	/**
	 * Negates the previous undo command 
	 * @throws IOException If an I/O error occurs
	 */
	public void redoPrevious() throws IOException {
		if (isPreviousUndo == false) {
			redoStack.clear();
		}
		
		if (redoStack.size() != 0) {
			ArrayList<Task> currentState = new ArrayList<Task>(redoStack.pop());
			undoStack.push(currentState);
			taskList = new ArrayList<Task>(currentState);
			permStorage.copyAllToFile(taskList);
		}
	}

	/**
	 * Sorts the tasks list by task name
	 * @throws IOException If an I/O error occurs
	 */
	public void sortByTaskName() throws IOException {
		Collections.sort(taskList, new TaskNameComparator());
		undoStack.push(new ArrayList<Task>(taskList));
		permStorage.copyAllToFile((taskList));
		isPreviousUndo = false;
	}

	/**
	 * Sorts the tasks list by time
	 * @throws IOException If an I/O error occurs
	 */
	public void sortByTime() throws IOException {
		Collections.sort(taskList, new TimeComparator());
		undoStack.push(new ArrayList<Task>(taskList));
		permStorage.copyAllToFile((taskList));
		isPreviousUndo = false;
	}

	/**
	 * Sorts the tasks list by priority
	 * @throws IOException If an I/O error occurs
	 */
	public void sortByPriority() throws IOException {
		Collections.sort(taskList, new PriorityComparator());
		undoStack.push(new ArrayList<Task>(taskList));
		permStorage.copyAllToFile((taskList));
		isPreviousUndo = false;
	}

	/**
	 * Changes the current working directory to the given path
	 * @param path The path of the file in the new working directory
	 * @throws IOException If an I/O error occurs
	 */
	public void moveToLocation(String path) throws IOException {
		permStorage.moveToLocation(path);
	}

	/**
	 * Loads and retrieves the tasks from the file based on the given path 
	 * @param path The path of the file to be loaded
	 * @throws IOException If an I/O error occurs
	 */
	public void loadFromFile(String path) throws IOException {
		permStorage.loadFromFile(path);
		taskList.clear();
		taskList = new ArrayList<Task>(retrieveListFromFile());
		undoStack.clear();
		undoStack.push(new ArrayList<Task>(taskList));
	}

	/**
	 * Makes a copy of the task file in the given path
	 * @param path The path of the file to be saved in
	 * @throws Exception If no file name is specified in the path
	 */
	public void saveToLocation(String path) throws IOException {
		permStorage.saveToLocation(path);
	}
	
	/**
	 * Returns a list of all overdue tasks relative to the given date
	 * @param date The date for the tasks to be checked overdue against
	 * @return The list of all overdue tasks relative to the given date
	 * @throws IOException If an I/O error occurs
	 */
	public ArrayList<Task> checkOverdue(Date date) throws IOException {
		ArrayList<Task> overdueList = new ArrayList<Task>();
		
		for (int i = taskList.size() - 1; i >= 0; i--) {
			Task task = taskList.get(i);
			
			if (task.getStatus().equals(TaskStatus.UPCOMING) && task.getTime().get(0).before(date)) {
				task.setStatus(TaskStatus.OVERDUE);
				permStorage.editToFile(i, task);
				taskList.remove(i);
				taskList.add(task);
				overdueList.add(task);
			}
		}
		return overdueList;
	}
	
	/**
	 * Returns a list of tasks that start or are ongoing on the given date
	 * @param date The date for the tasks to be shown
	 * @return The list of tasks that start or are ongoing on the given date
	 */
	public ArrayList<Task> showAllByDate(Date date) {
		ArrayList<Task> searchResults = new ArrayList<Task>();
		String dateString = date.toString().substring(0, 9);
		
		for (int i = 0; i < taskList.size(); i++) {
			Task task = taskList.get(i);
			
			if (task.getTime().size() == 1) {
				if (task.getTime().get(0).toString().substring(0, 9).equals(dateString)) {
					searchResults.add(task);
				}
			} else if (task.getTime().size() == 2) {
				if (date.after(task.getTime().get(0)) && date.before(task.getTime().get(1))) {
					searchResults.add(task);
				}
			}
		}
		return searchResults;
	}
	
	/**
	 * Returns a list of pending tasks that have the given priority level
	 * @param priority The priority for the tasks to be shown
	 * @return The list of tasks that have the given priority level
	 */
	public ArrayList<Task> showAllByPriority(PriorityLevel priority) {
		ArrayList<Task> searchResults = new ArrayList<Task>();
		
		for (int i = 0; i < taskList.size(); i++) {
			Task task = taskList.get(i);
			
			if (task.getPriority().equals(priority)) {
				searchResults.add(task);
			}
		}
		return searchResults;
	}
	
	/**
	 * Returns a list of tasks that matches the given string
	 * @param stringToSearch The string to be searched
	 * @return The list of completed tasks that matches the given string 
	 */
	public ArrayList<Task> searchMatch(String stringToSearch) {
		if (stringToSearch.contains(",")) {
			stringToSearch = stringToSearch.substring(0, stringToSearch.indexOf(","));
		}

		if (!stringToSearch.trim().contains(" ")) {
			stringToSearch = "";	
			searchHistory.clear();
		    searchHistory.push(taskList);
			prevSearch = "";

			return taskList;
		} else {
			stringToSearch = stringToSearch.substring(stringToSearch.indexOf(" ") + 1);
		}

		ArrayList<Task> currList;
		
		if (stringToSearch.length() < prevSearch.length()) {
			searchHistory.pop();
			prevSearch = stringToSearch;
			
			return searchHistory.peek();
		}
		else {
			currList = searchHistory.peek();
			ArrayList<Task> searchResult = new ArrayList<Task>();	
			String[] parts = stringToSearch.toLowerCase().split(" ");
			searchResult.clear();

			for (Task task : currList) {
				boolean match = true;
				String taskMatch = task.getTask();
						for (String part : parts) {
							if (!taskMatch.toLowerCase().contains(part)) {
								match = false;
								break;
							}
						}			
						if (match) {
							searchResult.add(task);
						}
			}
			prevSearch = stringToSearch;
			searchHistory.push(searchResult);

			return searchResult;
		}
	}
	
	/*
	 * Returns the index of the given task in the list
	 */
	private int searchTemp(Task task) {

		for (int i = 0; i < taskList.size(); i++) {
			Task thisTask = taskList.get(i);
			if (thisTask.getTask().equals(task.getTask()) && 
					thisTask.getTime().equals(task.getTime()) &&
					thisTask.getPriority().equals(task.getPriority())) {
				return i;
			}
		}
		return TASK_NOT_FOUND;
	}
	
	/*
	 * Returns a list of tasks retrieved from permanent storage
	 */
	private ArrayList<Task> retrieveListFromFile() throws IOException {
		ArrayList<Task> list = permStorage.readFromFile();
		Collections.sort(list, new TimeComparator());
		
		return list;
	}
}
```
###### main\java\storage\TempStorage.java
``` java

```
###### main\java\storage\TimeComparator.java
``` java
package main.java.storage;

import java.util.Comparator;

import main.java.data.Task;

/**
 * A Comparator for Task objects that can sort tasks based on their time
 * @author Hou Bo Wen
 *
 */
public class TimeComparator implements Comparator<Task>{

	@Override
	public int compare(Task task1, Task task2) {

		//Time is specified for both tasks
		if (!task1.getTime().isEmpty() && !task2.getTime().isEmpty()) {
			if (task1.getStatus().compareTo(task2.getStatus()) == 0) {

				if (task1.getTime().get(0).equals(task2.getTime().get(0))) {
					return task1.getTask().compareTo(task2.getTask());
				}
				else {
					return task1.getTime().get(0).compareTo(task2.getTime().get(0));
				}
			}
			else {
				return task1.getStatus().compareTo(task2.getStatus());
			}
		}
		//Time is specified for only task1
		else if (!task1.getTime().isEmpty()) {
			if (task1.getStatus().compareTo(task2.getStatus()) == 0) {
				return 1;
			}
			else {
				return task1.getStatus().compareTo(task2.getStatus());
			}
		}
		//Time is specified for only task2
		else if (!task2.getTime().isEmpty()) {
			if (task1.getStatus().compareTo(task2.getStatus()) == 0) {
				return -1;
			}
			else {
				return task1.getStatus().compareTo(task2.getStatus());
			}
		}
		//Time is not specified for both tasks
		else {
			return task1.getTask().compareTo(task2.getTask());

		}
	}
}
```
###### main\java\storage\TimeComparator.java
``` java

```
