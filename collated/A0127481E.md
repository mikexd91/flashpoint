# A0127481E
###### main\java\exception\InvalidInputFormatException.java
``` java
package main.java.exception;

/**
 * This class models an customized exception object to handle exception
 * caused by invalid input format
 * @author Ouyang Danwen
 *
 */
public class InvalidInputFormatException extends Exception {
	
	/**
	 * @param message
	 */
	public InvalidInputFormatException(String message) {
		super(message);
	}
}
```
###### main\java\exception\InvalidInputFormatException.java
``` java

```
###### main\java\gui\TasksItemController.java
``` java
	private boolean isToday(List<Date> dates) {
		int size = dates.size();
		if (size == 0) {
			return false;
		} else {
			Date today = new Date();
			String todayDate = today.toString().substring(0, 9);
			if (size == 1) {
				if (dates.get(0).toString().substring(0, 9).equals(todayDate)) {
					return true;
				}
			} else if (size == 2) {
				if (today.after(dates.get(0)) && today.before(dates.get(1))) {
					return true;
				}
			}
		}
		return false;
	}

	private String showTime(List<Date> dates) {
		SimpleDateFormat df = new SimpleDateFormat("EEEE dd MMM hh:mma");
		SimpleDateFormat df1 = new SimpleDateFormat("hh:mma");
		SimpleDateFormat df2 = new SimpleDateFormat("EEEE dd MMM");
		//SimpleDateFormat df3 = new SimpleDateFormat("EEEE");
		if (dates.size() == 0) {
			return "No specified time";
		} else {
			if (taskType == TaskType.DEADLINE) {
				return "Due: " + df.format(dates.get(0));
			} else if (taskType == TaskType.DURATION) {
				String time;
				// System.out.println(dates);
				if (dates.get(0).toString().substring(0, 10).equals(dates.get(1).toString().substring(0, 10))) {
					time = df2.format(dates.get(0)) + " " + df1.format(dates.get(0)) + " - " + df1.format(dates.get(1));
				} else {
					time = "" + df.format(dates.get(0)) + " to " + df.format(dates.get(1));
				}
				return time;
			} else {
				String time = "";
				for (int i = 0; i < dates.size(); i++) {
					time += df.format(dates.get(i));
					if (i + 1 < dates.size()) {
						time += ", ";
					}
				}
				return time;
			}
		
		}
	}

```
###### main\java\logic\CommandDispatcher.java
``` java
package main.java.logic;

import java.nio.file.InvalidPathException;

import main.java.data.Command;
import main.java.enumeration.CommandType;
import main.java.exception.InvalidInputFormatException;
import main.java.exception.NoFileNameException;
import main.java.parser.AddCommandParser;
import main.java.parser.DeleteCommandParser;
import main.java.parser.EditCommandParser;
import main.java.parser.ShowCommandParser;
import main.java.parser.SortCommandParser;
import main.java.parser.StorageCommandParser;


/**
 * This class dispatches all commands to be parsed accordingly before execution.
 * @author Ouyang Danwen
 *
 */
public class CommandDispatcher {
	
	/* error messages used in this class */
	private static final String ERROR_MESSAGE_EMPTY_COMMAND = ""
			+ "Please enter a non-empty command!";
	private static final String ERROR_MESSAGE_INVALID_COMMAND = ""
			+ "Please enter a valid command!";

	/* expression used for string manipulation */
	private static final String EMPTY_STRING = "";
	private static final String WHITE_SPACE = " ";

	/**
	 * Empty constructor for the class.
	 */
	public CommandDispatcher() {}
	
	/**
	 * @param command
	 * @return the parsed command
	 * @throws InvalidInputFormatException
	 * @throws NoFileNameException 
	 */
	public Command parseCommand(Command command)throws InvalidInputFormatException, 
	NoFileNameException, InvalidPathException {
		assert command != null;
		String originalCommand = command.getOriginal();

		if (originalCommand.isEmpty()) {
			throw new InvalidInputFormatException(ERROR_MESSAGE_EMPTY_COMMAND);
		}

		command.setType(determineCommandType(originalCommand));
		String commandContent = retrieveCommandContent(command);
		command.setContent(commandContent);
		setParameters(command);
		return command;
	}

	/**
	 * Dispatch the commands for parsing and set their parameters respectively.
	 * @param command
	 * @throws InvalidInputFormatException
	 * @throws NoFileNameException 
	 */
	private void setParameters(Command command)throws InvalidInputFormatException, 
	NoFileNameException, InvalidPathException {
		assert command != null;

		if (command.isCommand(CommandType.ADD)) {
			AddCommandParser parser = new AddCommandParser();
			command.setParameters(parser.determineParameters
					(command.getContent()));
		}
		
		else if (command.isCommand(CommandType.EDIT)) {
			EditCommandParser parser = new EditCommandParser();
			command.setParameters(parser.determineParameters
					(command.getContent()));
		}
		
		else if (command.isCommand(CommandType.DELETE)) {
			DeleteCommandParser parser = new DeleteCommandParser();
			command.setParameters(parser.determineParameters
					(command.getContent()));
		}
		
		else if (command.isCommand(CommandType.DELETE_COMPLETE)) {
			DeleteCommandParser parser = new DeleteCommandParser();
			command.setParameters(parser.determineParameters
					(command.getContent()));
		}
		
		else if (command.isCommand(CommandType.MOVE)) {
			StorageCommandParser parser = new StorageCommandParser();
			command.setParameters(parser.determineParameters
					(command.getType(),command.getContent()));
		}
		
		else if (command.isCommand(CommandType.SAVE)) {
			StorageCommandParser parser = new StorageCommandParser();
			command.setParameters(parser.determineParameters
					(command.getType(),command.getContent()));
		}
		
		else if (command.isCommand(CommandType.OPEN)) {
			StorageCommandParser parser = new StorageCommandParser();
			command.setParameters(parser.determineParameters
					(command.getType(),command.getContent()));
		}
		
		else if (command.isCommand(CommandType.SORT)
				|| command.isCommand(CommandType.SORT_COMPLETE)) {
			SortCommandParser parser = new SortCommandParser();
			command.setParameters(parser.determineParameters
					(command.getContent()));
		}
		
		else if (command.isCommand(CommandType.SHOW) 
				|| command.isCommand(CommandType.SHOW_COMPLETE)) {
			ShowCommandParser parser = new ShowCommandParser();
			command.setParameters(parser.determineParameters
					(command.getContent()));
		}

		else if (command.isCommand(CommandType.INVALID)){
			throw new InvalidInputFormatException(ERROR_MESSAGE_INVALID_COMMAND);
		}

		//other commands which need not to be parsed
		else {
			return;
		}

	}

	/**
	 * @param originalCommand
	 * @return command type
	 */
	private CommandType determineCommandType(String originalCommand) {
		assert originalCommand != null;

		CommandType type = getCommandKeyword(originalCommand);
		return type;
	}

	/**
	 * @param command
	 * @return the command keyword
	 */
	private CommandType getCommandKeyword(String command) {
		assert command != null;

		String firstWord = getFirstKeyword(command);

		if (isCommand(CommandType.ADD, firstWord)) {
			return CommandType.ADD;
		}

		else if (isCommand(CommandType.DELETE, firstWord)) {
			return CommandType.DELETE;
		}

		else if (isCommand(CommandType.DELETE_COMPLETE, firstWord)) {
			return CommandType.DELETE_COMPLETE;
		}

		else if (isCommand(CommandType.SEARCH, firstWord)) {
			return CommandType.SEARCH;
		}

		else if (isCommand(CommandType.MOVE, firstWord)) {
			return CommandType.MOVE;
		}
		else if (isCommand(CommandType.SAVE, firstWord)) {
			return CommandType.SAVE;
		}

		else if (isCommand(CommandType.SORT, firstWord)) {
			return CommandType.SORT;
		}

		else if (isCommand(CommandType.SORT_COMPLETE, firstWord)) {
			return CommandType.SORT_COMPLETE;
		}

		else if (isCommand(CommandType.CLEAR_UPCOMING, firstWord)) {
			return CommandType.CLEAR_UPCOMING;
		}

		else if (isCommand(CommandType.CLEAR_ALL, firstWord)) {
			return CommandType.CLEAR_ALL;
		}

		else if (isCommand(CommandType.CLEAR_FLOATING, firstWord)) {
			return CommandType.CLEAR_FLOATING;
		}

		else if (isCommand(CommandType.CLEAR_OVERDUE, firstWord)) {
			return CommandType.CLEAR_OVERDUE;
		}

		else if (isCommand(CommandType.CLEAR_COMPLETE, firstWord)) {
			return CommandType.CLEAR_COMPLETE;
		}

		else if (isCommand(CommandType.EDIT, firstWord)) {
			return CommandType.EDIT;
		}

		else if (isCommand(CommandType.UNDO, firstWord)) {
			return CommandType.UNDO;
		}

		else if (isCommand(CommandType.REDO, firstWord)) {
			return CommandType.REDO;
		}

		else if (isCommand(CommandType.MARK, firstWord)) {
			return CommandType.MARK;
		}

		else if (isCommand(CommandType.UNMARK, firstWord)) {
			return CommandType.UNMARK;
		}

		else if (isCommand(CommandType.SWITCH, firstWord)) {
			return CommandType.SWITCH;
		}

		else if (isCommand(CommandType.SHOW, firstWord)) {
			return CommandType.SHOW;
		}

		else if (isCommand(CommandType.SHOW_COMPLETE, firstWord)) {
			return CommandType.SHOW_COMPLETE;
		}
		
		else if (isCommand(CommandType.OPEN, firstWord)) {
			return CommandType.OPEN;
		}

		else {
			return CommandType.INVALID;
		}

	}

	/**
	 * @param command
	 * @return the first word of each command
	 */
	private String getFirstKeyword(String command) {
		assert command != null;

		//only one word in command -> it is the keyword required
		if (!command.contains(WHITE_SPACE)) {
			return command;
		}

		return command.substring(0,command.indexOf(WHITE_SPACE)).trim();
	}

	/**
	 * Determine whether the command has a certain type.
	 * Return true if it is of the type or false otherwise.
	 * @param type
	 * @param keyword
	 * @return true or false
	 */
	private boolean isCommand(CommandType type, String keyword) {
		assert keyword != null;

		return type.getType().equalsIgnoreCase(keyword);
	}

	/**
	 * @param command
	 * @return the command content excluding the command keyword
	 */
	private String retrieveCommandContent(Command command) {
		assert command != null;

		String original = command.getOriginal();

		//command content is empty
		if (!original.contains(WHITE_SPACE)) {
			return EMPTY_STRING;
		}

		//command content is not empty
		else {
			String content = original.substring(original.indexOf(WHITE_SPACE) + 1);
			return content.trim();
		}
	}
}
```
###### main\java\logic\CommandDispatcher.java
``` java

```
###### main\java\logic\Logic.java
``` java
package main.java.logic;

/* import statements */
import java.io.IOException;
import java.nio.file.InvalidPathException;
import java.util.ArrayList;
import java.util.Date;
import org.ocpsoft.prettytime.nlp.PrettyTimeParser;

import main.java.data.Command;
import main.java.data.Task;
import main.java.data.TransientTask;
import main.java.enumeration.CommandType;
import main.java.enumeration.PriorityLevel;
import main.java.exception.InvalidInputFormatException;
import main.java.exception.NoFileNameException;
import main.java.parser.EditCommandParser;
import main.java.storage.StorageController;

/**
 * This class models the core component, Logic, of the application.
 * It handles the high level logic flow: receive user command -> parse user command
 * -> create user task -> save task to storage.
 * @author Ouyang Danwen
 *
 */
public class Logic {

	/* string constants used in this class */
	private static final String COMMAND_ADD = "add";
	private static final String COMMAND_DELETE = "delete";
	private static final String COMMAND_SEARCH = "search";
	private static final String COMMAND_SAVE = "save";
	private static final String COMMAND_SORT = "sort";
	private static final String COMMAND_EDIT = "edit";
	private static final String COMMAND_UNDO = "undo";
	private static final String COMMAND_HELP = "help";
	private static final String COMMAND_MARK = "mark";
	private static final String COMMAND_UNMARK = "unmark";
	private static final String COMMAND_CLEAR = "clear";
	private static final String COMMAND_SWITCH = "switch";
	private static final String COMMAND_REDO = "redo";
	private static final String COMMAND_THEME = "theme";
	private static final String COMMAND_SHOW = "show";
	private static final String COMMAND_OPEN = "open";
	private static final String EDIT_COMMAND_SEPARATOR = ",";
	private static final String TIME_EMPTY = "[]";
	private static final String STRING_TIME = "time";
	private static final String STRING_PRIORITY = "priority";
	private static final String STRING_NAME = "name";
	private static final String KEYWORD_UNMARK = "unmark ";
	private static final String KEYWORD_MARK = "mark ";
	private static final String KEYWORD_DELETE = "delete ";
	private static final String KEYWORD_COMPLETE_DELETE = "deleteComplete ";
	private static final String COMMAND_MOVE = "move";
	/* numeric indices to access the parameters array */
	private static final int TASK = 0;
	private static final int TIME = 1;
	private static final int PRIORITY = 2;

	/* attributes of the class */
	private static Task task;
	private static TransientTask transientTask;
	private static StorageController storageController;
	private ArrayList<Task> searchResult;
	private ArrayList<Task> searchResultCompleted;
	
	private static PrettyTimeParser timeParser = new PrettyTimeParser();

	/**
	 * @throws IOException
	 */
	public Logic() throws IOException {
		storageController = new StorageController();
	}

	/**
	 * @param userInput
	 * @param taskOptions
	 * @return the resultant list after executing the command
	 * @throws InvalidInputFormatException 
	 * @throws NoFileNameException 
	 * @throws IOException 
	 */
	public ArrayList<Task> handleUserCommand(String userInput,ArrayList<Task> taskOptions) 
			throws InvalidInputFormatException, IOException, NoFileNameException {
		assert userInput != null;

		CommandDispatcher dispatcher = new CommandDispatcher();
		Command command = new Command(userInput);
		command = parseCommand(dispatcher, command);

		ArrayList<Task> result = executeCommand(command, taskOptions, userInput);

		return result;

	}

	/**
	 * @param dispatcher
	 * @param command
	 * @return the parsed command 
	 * @throws InvalidInputFormatException
	 * @throws NoFileNameException 
	 */
	private Command parseCommand(CommandDispatcher dispatcher, Command command)
			throws InvalidInputFormatException, NoFileNameException, 
			InvalidPathException {
		assert command != null;
		return dispatcher.parseCommand(command);
	}

	/**
	 * @param command
	 * @param taskOptions
	 * @param userInput
	 * @return resultant task list after execution of the command
	 * @throws IOException 
	 * @throws NoFileNameException
	 */
	private ArrayList<Task> executeCommand(Command command, ArrayList<Task> taskOptions,
			String userInput) throws IOException, NoFileNameException  {
		assert command != null;
		assert userInput != null;

		ArrayList<Task> result = new ArrayList<Task>();

		if (command.isCommand(CommandType.ADD)) {
			result = handleAddCommand(command);
		}

		else if (command.isCommand(CommandType.CLEAR_ALL)){
			result = handleClearAllCommand();
		}

		else if (command.isCommand(CommandType.CLEAR_FLOATING)){
			result = handleClearFloatingTaskCommand();
		}

		else if (command.isCommand(CommandType.CLEAR_UPCOMING)){
			result = handleClearUpcomingTaskCommand();
		}

		else if (command.isCommand(CommandType.CLEAR_OVERDUE)){
			result = handleClearOverdueTaskCommand();
		}

		else if (command.isCommand(CommandType.CLEAR_COMPLETE)){
			result = handleClearCompleteTaskCommand();
		}

		else if (command.isCommand(CommandType.DELETE)) {
			handleDeleteTaskCommand(userInput);
		}

		else if (command.isCommand(CommandType.DELETE_COMPLETE)) {
			handleDeleteCompleteTaskCommand(userInput);
		}

		else if (command.isCommand(CommandType.EDIT)) {
			handleEditCommand(result, userInput, command);
		}

		else if (command.isCommand(CommandType.MOVE)) {
			handleMoveCommand(command);
		}

		else if (command.isCommand(CommandType.SAVE)) {
			handleSaveCommand(command);
		}
		
		else if (command.isCommand(CommandType.OPEN)) {
			handleOpenCommand(command);
		}
		
		else if (command.isCommand(CommandType.MARK)) {
			handleMarkCommand(userInput);
		}

		else if (command.isCommand(CommandType.UNMARK)) {
			handleUnmarkCommand(userInput);
		}

		else if (command.isCommand(CommandType.SHOW)) {
			result = handleShowCommand(command);
		}

		else if (command.isCommand(CommandType.SHOW_COMPLETE)) {
			result = handleShowCompleteCommand(command);
		}

		else if (command.isCommand(CommandType.SORT)) {
			handleSortCommand(command);
		}

		else if (command.isCommand(CommandType.SORT_COMPLETE)) {
			handleSortCompleteCommand(command);
		}


		else if (command.isCommand(CommandType.UNDO)) {
			handleUndoCommand();
		}

		else if (command.isCommand(CommandType.REDO)) {
			handleRedoCommand();
		}

		return result;
	}

	/**
	 * @param command
	 * @throws IOException
	 */
	private void handleSortCompleteCommand(Command command) throws IOException {
		assert command != null;

		String parameter = command.getParameters()[TASK].toLowerCase();

		if (parameter.equals(STRING_TIME)) {
			storageController.sortCompletedByTime();
		}

		else if (parameter.equals(STRING_NAME)) {
			storageController.sortCompletedByTaskName();
		}

		else if (parameter.equals(STRING_PRIORITY)) {
			storageController.sortCompletedByPriority();
		} 	
	}


	/**
	 * @param command
	 * @throws IOException
	 */
	private void handleSortCommand(Command command) throws IOException {
		assert command != null;

		String parameter = command.getParameters()[TASK].toLowerCase();

		if (parameter.equals(STRING_TIME)) {
			storageController.sortPendingByTime();
		}

		else if (parameter.equals(STRING_NAME)) {
			storageController.sortPendingByTaskName();
		}

		else if (parameter.equals(STRING_PRIORITY)) {
			storageController.sortPendingByPriority();
		}	
	}


	/**
	 * @throws IOException
	 */
	private void handleRedoCommand() throws IOException {
		storageController.redo();
	}


	/**
	 * @throws IOException
	 */
	private void handleUndoCommand() throws IOException {
		storageController.undo();	
	}


	/**
	 * @param command
	 * @return the resultant task list to show
	 */
	private ArrayList<Task> handleShowCompleteCommand(Command command) {
		assert command != null;

		boolean isTime = false;
		ArrayList<Task> result;
		Date timeFilter = null;
		PriorityLevel priorityFilter = null;

		//filter by time
		if (command.getParameters()[TIME] != null) {
			isTime = true;
			timeFilter = timeParser.parse(command
					.getParameters()[TIME]).get(0);

		}

		//filter by priority
		else {
			priorityFilter = determinePriorityFilter(command);
		}

		//show by time filter
		if (isTime) {
			result = storageController.showAllCompletedByDate(timeFilter);
		}

		//show by  priority filter
		else {
			result = storageController.showAllCompletedByPriority(priorityFilter);
		}	

		return result;
	}


	/**
	 * @param command
	 * @return the resultant task list to show
	 */
	private ArrayList<Task> handleShowCommand(Command command) {
		assert command != null;

		ArrayList<Task> result;
		Date timeFilter = null;
		PriorityLevel priorityFilter = null;
		boolean isTime = false;

		//filter by time
		if (command.getParameters()[TIME] != null) {
			isTime = true;
			timeFilter = timeParser.parse(command
					.getParameters()[TIME]).get(0);
		}

		//filter by priority
		else {
			priorityFilter = determinePriorityFilter(command);
		}

		//show by time filter
		if (isTime) {
			result = storageController.showAllPendingByDate(timeFilter);
		}

		//show by priority filter
		else {
			result = storageController.showAllPendingByPriority(priorityFilter);
		}

		return result;

	}


	/**
	 * @param command
	 * @return the priority filter for the sort command
	 */
	private PriorityLevel determinePriorityFilter(Command command) {
		assert command != null;

		String priority = command.getParameters()[PRIORITY];
		PriorityLevel priorityFilter;

		if (priority.equals(PriorityLevel.HIGH.getType())) {
			priorityFilter = PriorityLevel.HIGH;
		}

		else if (priority.equals(PriorityLevel.MEDIUM.getType())) {
			priorityFilter = PriorityLevel.MEDIUM;
		}

		else {
			priorityFilter = PriorityLevel.LOW;
		}

		return priorityFilter;
	}


	/**
	 * @param userInput
	 * @throws IOException 
	 */
	private void handleUnmarkCommand(String userInput) throws IOException {
		assert userInput != null;

		for (Task temp : searchResultCompleted) {

			//only unmark when the command is valid and there is only one match
			if (userInput.equalsIgnoreCase(KEYWORD_UNMARK + temp.getTask()) 
					|| searchResultCompleted.size()==1) {
				unmark(temp);			
				break;
			}			
		}	
	}


	/**
	 * @param userInput
	 * @throws IOException 
	 */
	private void handleMarkCommand(String userInput) throws IOException {
		assert userInput != null;

		for (Task temp : searchResult) {

			//only mark when the command is valid and there is only one match
			if (userInput.equalsIgnoreCase(KEYWORD_MARK + temp.getTask()) 
					|| searchResult.size()==1) {
				mark(temp);			
				break;
			}			
		}	
	}


	/**
	 * Save file to a different location.
	 * @param command
	 * @throws IOException 
	 * @throws NoFileNameException 
	 */
	private void handleSaveCommand(Command command) throws NoFileNameException, IOException {
		assert command != null;
		saveToLocation(command.getParameters()[TASK]);
	}


	/**
	 * Move saved file to a different location.
	 * @param command
	 * @throws IOException 
	 */
	private void handleMoveCommand(Command command) throws IOException {
		assert command != null;
		moveToLocation(command.getParameters()[TASK]);	
	}
	
	/**
	 * Open a file from a specified location.
	 * @param command
	 * @throws IOException
	 */
	private void handleOpenCommand(Command command) throws IOException {
		assert command != null;
		loadFilename(command.getParameters()[TASK]);
	}


	/**
	 * @param result
	 * @param userInput
	 * @param command
	 * @throws IOException 
	 */
	private void handleEditCommand(ArrayList<Task> result, String userInput, 
			Command command) throws IOException {
		assert result != null;
		assert userInput != null;
		assert command != null;

		ArrayList<Task> finalResult = new ArrayList<Task>(); 

		//create the transient task for parsing
		transientTask = createTransientTask(command);

		//parse the editCommand
		result = parseEditCommand(transientTask);

		//get the original task information
		String originalTask = userInput.substring(5, userInput.indexOf(EDIT_COMMAND_SEPARATOR));

		executeEditCommand(userInput, finalResult, result, originalTask);

	}


	/**
	 * @param userInput
	 * @param finalResult
	 * @param result
	 * @param originalTask
	 * @throws IOException 
	 */
	private void executeEditCommand(String userInput, ArrayList<Task> finalResult, 
			ArrayList<Task> result, String originalTask) throws IOException {
		assert userInput != null;
		assert finalResult != null;
		assert result != null;
		assert originalTask != null;

		for (Task temp : searchResult) {

			//check if it is the right task to edit
			if (temp.getTask().contains(originalTask)) {				
				finalResult.add(temp);	  
				finalResult.add(result.get(1));

				Task original = finalResult.get(0);

				Task updated = finalResult.get(1);

				//not update time -> retain the original time, type and status
				if(updated.getTime().toString().equals(TIME_EMPTY)){
					updated.setTime(original.getTime());
					updated.setType(original.getType());
					updated.setStatus(original.getStatus());
				}

				//not update priority -> retain the original priority
				if(updated.getPriority()== PriorityLevel.NOT_SPECIFIED){
					updated.setPriority(original.getPriority());
				}

				edit(finalResult);
				break;
			}
		}

	}


	/**
	 * @param userInput
	 * @throws IOException 
	 */
	private void handleDeleteTaskCommand(String userInput) throws IOException{
		assert userInput != null;

		for (Task temp : searchResult) {

			//delete the task only if there is one match and the command is valid
			if (userInput.equalsIgnoreCase(KEYWORD_DELETE + temp.getTask()) 
					|| searchResult.size()==1) {
				delete(temp);			
				break;
			}			
		}
	}


	/**
	 * @param userInput
	 * @throws IOException 
	 */
	private void handleDeleteCompleteTaskCommand(String userInput) throws IOException {
		assert userInput != null;

		for (Task temp : searchResultCompleted) {

			//delete the task only if there is one match and the command is valid
			if (userInput.equalsIgnoreCase(KEYWORD_COMPLETE_DELETE + temp.getTask())
					|| searchResultCompleted.size()==1) {
				deleteComplete(temp);			
				break;
			}			
		}
	}

	/**
	 * @return the resultant task list for display under "completed tasks" tab
	 * @throws IOException
	 */
	private ArrayList<Task> handleClearCompleteTaskCommand() throws IOException {
		storageController.clearCompletedTasks();
		return storageController.displayCompletedTasks();
	}


	/**
	 * @return the resultant task list for display under "overdue tasks" tab
	 * @throws IOException
	 */
	private ArrayList<Task> handleClearOverdueTaskCommand() throws IOException {
		storageController.clearOverdueTasks();
		return storageController.displayPendingTasks();
	}


	/**
	 * @return the resultant task list for display under "pending tasks" tab
	 * @throws IOException
	 */
	private ArrayList<Task> handleClearUpcomingTaskCommand() throws IOException {
		storageController.clearUpcomingTasks();
		return storageController.displayPendingTasks();
	}


	/**
	 * @return the resultant task list for display under "floating tasks" tab
	 * @throws IOException
	 */
	private ArrayList<Task> handleClearFloatingTaskCommand() throws IOException {
		storageController.clearFloatingTasks();
		return storageController.displayPendingTasks();
	}


	/**
	 * @return the resultant task list for display under "all tasks" tab
	 * @throws IOException
	 */
	private ArrayList<Task> handleClearAllCommand() throws IOException {
		storageController.clearAllPendingTasks();
		return storageController.displayPendingTasks();
	}


	/**
	 * @param command
	 * @return the resultant task list after adding the task
	 * @throws IOException 
	 */
	private ArrayList<Task> handleAddCommand(Command command) throws IOException {
		assert task != null;

		task = createTask(command);
		storageController.addTask(task);

		return storageController.displayPendingTasks();
	}


	/**
	 * @param task
	 * @return the parsed edit command to  return two tasks
	 */
	private ArrayList<Task> parseEditCommand(TransientTask task) {
		assert task != null;
		return EditCommandParser.parseEditTask(task);
	}

	/**
	 * @param command
	 * @return the task object created from the parsed command
	 */
	private Task createTask(Command command) {
		assert command != null;
		return command.createTask();
	}

	/**
	 * @param command
	 * @return the transient task object from the parsed edit command
	 */
	private TransientTask createTransientTask(Command command) {
		assert command != null;
		return command.createTransientTask();
	}

	/**
	 * Delete a completed task.
	 * @param task
	 * @throws IOException 
	 */
	public void deleteComplete(Task task) throws IOException {
		assert task != null;
		storageController.deleteCompletedTask(task);
	}

	/**
	 * Delete a task.
	 * @param task
	 * @throws IOException  
	 */
	public void delete(Task task) throws IOException {
		assert task != null;
		storageController.deletePendingTask(task);
	}

	/**
	 * Mark a task as completed.
	 * @param task
	 * @throws IOException 
	 */
	public void mark(Task task) throws IOException {
		assert task != null;
		storageController.moveTaskToComplete(task);	
	}

	/**
	 * Unmark a completed task as uncompleted.
	 * @param task
	 * @throws IOException 
	 */
	public void unmark(Task task) throws IOException {
		assert task != null;
		storageController.moveTaskToPending(task);
	}

	/**
	 *Display all upcoming tasks under the "pending tasks" tab.
	 * @return the list of pending tasks
	 */
	public ArrayList<Task> displayPending() {
		ArrayList<Task> result = storageController.displayPendingTasks();
		return result;
	}

	/**
	 * Display the list of completed task under the "completed tasks" tab.
	 * @return the list of the completed task
	 */
	public ArrayList<Task> displayComplete() {
		ArrayList<Task> result = storageController.displayCompletedTasks();
		return result;
	}

	/**
	 * Edit a task after locating the original task.
	 * @param result
	 * @throws IOException 
	 */
	public void edit(ArrayList<Task> result) throws IOException{
		assert result != null;
		storageController.editPendingTask(result.get(0), result.get(1));
	}

	/**
	 * Move the saved file to a new location on PC.
	 * @param path
	 * @throws IOException 
	 */
	public void moveToLocation(String path) throws IOException {	
		assert path != null;
		storageController.moveToLocation(path);
	}

	/**
	 * Load a file from PC based on the given file name.
	 * @param fileName
	 * @throws IOException
	 */
	public void loadFilename(String filename) throws IOException {	
		assert filename != null;
		storageController.loadFromFile(filename);
	}

	/**
	 * Save the file to a particular location.
	 * @param path
	 * @throws NoFileNameException 
	 * @throws IOException 
	 */
	public void saveToLocation(String path) throws NoFileNameException, IOException {
		assert path != null;
		storageController.saveToLocation(path);
	}

	/**
	 * Determine whether the command is a valid command based on the command keyword.
	 * Return true if it is a valid command or false otherwise.
	 * @param commandWord
	 * @return true or false.
	 */
	public boolean isCommand(String commandWord) {
		assert commandWord != null;

		commandWord = commandWord.toLowerCase();
		if(commandWord.equals(COMMAND_ADD)|| commandWord.equals(COMMAND_DELETE)
				|| commandWord.equals(COMMAND_EDIT)|| commandWord.equals(COMMAND_SEARCH)
				|| commandWord.equals(COMMAND_SORT) || commandWord.equals(COMMAND_CLEAR)
				|| commandWord.equals(COMMAND_UNDO) || commandWord.equals(COMMAND_HELP) 
				|| commandWord.equals(COMMAND_MARK) || commandWord.equals(COMMAND_REDO) 
				|| commandWord.equals(COMMAND_SWITCH) || commandWord.equals(COMMAND_UNMARK)
				|| commandWord.equals(COMMAND_THEME) || commandWord.equals(COMMAND_SHOW)
				|| commandWord.equals(COMMAND_SAVE) || commandWord.equals(COMMAND_OPEN)
				|| commandWord.equals(COMMAND_MOVE)) {
			return true;
		}

		else {
			return false;
		}
	}


	/**
	 * Search the upcoming task list for matched based on the specified value.
	 * @param oldValue
	 * @return the search result from all upcoming tasks as a task list
	 */
	public ArrayList<Task> handleSearchPending(String newValue) {
		assert newValue != null;
		searchResult = storageController.searchMatchPending(newValue);	
		return searchResult;
	}


	/**
	 * Search the completed task list for matched based on the specified value.
	 * @param oldValue
	 * @return the search result from all completed tasks as a task list
	 */
	public ArrayList<Task> handleSearchCompleted(String newValue) {
		assert newValue != null;
		searchResultCompleted = storageController.searchMatchCompleted(newValue);	
		return searchResultCompleted;
	}


	/**
	 * Check through the whole upcoming task list
	 * to mark all overdue task as overdue.
	 * @return the new task list after checking
	 * @throws IOException
	 */
	public ArrayList<Task> checkOverdue() throws IOException  {
		return storageController.checkOverdue(new Date());
	}

	/**
	 * Parse the string to a numeric index.
	 * @param command
	 * @return the numeric task index
	 */
	public int retrieveTaskIndex(Command command) {
		assert command != null;

		CommandType type = command.getType();
		String content = command.getContent();

		//delete by index
		if (type == CommandType.DELETE) {
				return Integer.parseInt(content);
		}

		//edit by index
		else if (type == CommandType.EDIT) {
			content = content.substring(0, content.indexOf(EDIT_COMMAND_SEPARATOR));
				return Integer.parseInt(content);
		}

		//other commands do not execute by index
		else {
			return -1;
		}
	}
	
	/**
	 * @return Task
	 */
	public Task getTask(){
		return task;
	}
	
}
```
###### main\java\logic\Logic.java
``` java

```
###### main\java\parser\AddCommandParser.java
``` java
package main.java.parser;

/* import statements */
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.PriorityQueue;
import org.apache.commons.lang3.StringUtils;
import org.ocpsoft.prettytime.nlp.PrettyTimeParser;

import main.java.enumeration.PriorityLevel;
import main.java.enumeration.TaskType;
import main.java.exception.InvalidInputFormatException;

/**
 * This class formats and parses the add command.
 * @author Ouyang Danwen
 *
 */
public class AddCommandParser {

	/* error messages used in this class */
	private static final String ERROR_MESSAGE_EMPTY_TASK = "Cannot add an empty task!";
	private static final String ERROR_MESSAGE_MISSING_TASK_NAME = "Task name is missing!";
	private static final String ERROR_MESSAGE_AMBIGUOUS_TIME = "Ambiguous time entered!";
	private static final String ERROR_MESSAGE_UNSUPPORTED_DATE_FORMAT = ""
			+ "Date format not supported!";
	private static final String ERROR_MESSAGE_INVALID_PRIORITY = ""
			+ "Please enter a valid priority level";

	/* string constants used in this class */
	private static final String DEADLINE_FLAG_BY = "by";
	private static final String DEADLINE_FLAG_BEFORE = "before";
	private static final String EVENT_FLAG_ON = "on";
	private static final String EVENT_FLAG_AT = "at";
	private static final String DURATION_FLAG_FROM = "from";
	private static final String DURATION_FLAG_TO = "to";
	private static final String PRIORITY_FLAG = "#";	
	private static final String TIME_EMPTY = "[]";
	private static final String TIME_SEPARATOR = ":";
	private static final String EXTRA_WHITE_SPACES = "\\s+";
	private static final String STRING_WHITE_SPACE = " ";
	private static final String QUOTATION = "\"";
	private static final String TOMORROW_IN_FULL = "tomorrow";
	private static final String TOMORROW_IN_SHORT = "tmr";
	private static final String STRING_EMPTY = "";
	private static final String STRING_NOW = "now";
	private static final String STRING_TODAY = "today";
	private static final String DEFAULT_TIME = "8am";
	private static final String TASK_OVERDUE = "overdue";
	private static final String TASK_UPCOMING = "upcoming";
	private static final String TASK_FLOATING = "floating";
	private static final String ALIAS_PRIORITY_HIGH = "h";
	private static final String ALIAS_1_PRIORITY_MEDIUM = "med";
	private static final String ALIAS_2_PRIORITY_MEDIUM = "m";
	private static final String ALIAS_PRIORITY_LOW = "l";

	/* numeric constants used in this class */
	private static final int FIELD_NOT_EXIST = -1;
	private static final int TASK = 0;
	private static final int TIME = 1;
	private static final int PRIORITY = 2;
	private static final int TASK_TYPE = 3;
	private static final int STATUS = 4;

	/* attributes of the class */
	protected PrettyTimeParser timeParser;

	public AddCommandParser() {
		timeParser = new PrettyTimeParser();
	}

	/**
	 * @param commandContent
	 * @return parameters of the command as a string array
	 * @throws InvalidInputFormatException
	 */
	public String[] determineParameters(String commandContent) 
			throws InvalidInputFormatException {
		assert commandContent != null;

		//task description cannot be empty
		if (commandContent.isEmpty()) {
			throw new InvalidInputFormatException(ERROR_MESSAGE_EMPTY_TASK);
		}

		//determine parameters of the command
		String formattedCommandContent = formatToStandardCommandContent(commandContent);
		String timeSegment = determineTimeSegment(formattedCommandContent.toLowerCase());
		String[] commandParameters;
		commandParameters = setParameters(formattedCommandContent, timeSegment);

		return commandParameters;
	}

	/**
	 * @param formattedCommandContent
	 * @param timeSegment
	 * @return the command parameters after setting them
	 * @throws InvalidInputFormatException
	 */
	private String[] setParameters(String formattedCommandContent, String timeSegment) 
			throws InvalidInputFormatException {
		assert formattedCommandContent != null;
		assert timeSegment != null;

		String[] commandParameters = new String[5];

		//determine all the parameters
		commandParameters[TASK] = determineTask(formattedCommandContent);

		if (commandParameters[TASK].isEmpty()) {       //task name cannot be empty
			throw new InvalidInputFormatException(ERROR_MESSAGE_MISSING_TASK_NAME);
		}
		commandParameters[TIME] = determineTime(timeSegment);
		commandParameters[PRIORITY] = determinePriority(formattedCommandContent);
		commandParameters[TASK_TYPE] = determineTaskType(formattedCommandContent);
		commandParameters[STATUS] = determineStatus(timeSegment);

		return commandParameters;
	}

	/**
	 * Determine the name of the task.
	 * @param formattedCommandContent
	 * @return task name
	 * @throws InvalidInputFormatException
	 */
	protected String determineTask(String formattedCommandContent) 
			throws InvalidInputFormatException {
		assert formattedCommandContent != null;

		int timeIndex = getStartingIndexOfIdentifier(formattedCommandContent);

		//no time specified
		if (timeIndex == FIELD_NOT_EXIST) {
			return determineTaskWithNoTimeSpecified(formattedCommandContent);
		}

		//time is specified
		else {
			return determineTaskWithTimeSpecified(formattedCommandContent, timeIndex);
		}
	}

	/**
	 * @param formattedCommandContent
	 * @param timeIndex
	 * @return task name
	 */
	private String determineTaskWithTimeSpecified(String formattedCommandContent, 
			int timeIndex) {
		assert formattedCommandContent != null;

		//time is the first segment -> task is missing
		if (timeIndex == 0) {
			return STRING_EMPTY;
		}

		//task is present
		else {
			return formattedCommandContent.substring(0, timeIndex - 1);
		}
	}

	/**
	 * @param formattedCommandContent
	 * @return task name
	 */
	private String determineTaskWithNoTimeSpecified(String formattedCommandContent) {
		assert formattedCommandContent != null;

		int priorityIndex = getStartingIndexOfPriority(formattedCommandContent);

		//no priority specified
		if (priorityIndex == FIELD_NOT_EXIST) {
			return formattedCommandContent;      //commandContent is the task
		}

		//priority is specified
		else {

			//priority is the first segment -> task is missing
			if (priorityIndex == 0) {
				return STRING_EMPTY;
			}

			//task is present
			else {
				return formattedCommandContent.substring(0, priorityIndex - 1);
			}
		}
	}

	/**
	 * @param formattedCommandContent
	 * @return time of the task
	 * @throws InvalidInputFormatException
	 */
	protected String determineTime(String formattedCommandContent) 
			throws InvalidInputFormatException {
		assert formattedCommandContent != null;

		String timeSegment = determineTimeSegment(formattedCommandContent);
		List<Date> dates = timeParser.parse(timeSegment);

		//no time present
		if (dates.isEmpty()) {
			return TIME_EMPTY;
		}

		//time is present
		else {
			String time = formatTimeSegment(dates, timeSegment);
			return time;
		}
	}

	/**
	 * Format the time segment for esay manipulation.
	 * @param dates
	 * @param timeSegment
	 * @return the formatted time segment
	 * @throws InvalidInputFormatException
	 */
	private String formatTimeSegment(List<Date> dates, String timeSegment) 
			throws InvalidInputFormatException {
		assert timeSegment != null;

		//check the validity of input time
		isTimeAmbiguous(dates, timeSegment);

		//convert to string for easy manipulation
		String time = dates.toString();

		//do not set to default time if "now" is specified
		if (!timeSegment.contains(STRING_NOW)) {
			time = setDefaultTimeIfNotSpecified(timeSegment, dates);
		}
		return time;
	}

	/**
	 * @param dates
	 * @param timeSegment
	 * @throws InvalidInputFormatException
	 */
	private void isTimeAmbiguous(List<Date> dates, String timeSegment) 
			throws InvalidInputFormatException {
		assert dates != null;
		assert timeSegment != null;

		int size = dates.size();

		//not handling input with more than two different time
		if (size > 2) {
			throw new InvalidInputFormatException(ERROR_MESSAGE_AMBIGUOUS_TIME);
		}

		//only handles "from time_A to time_B" for input with two different time specified
		else if (size == 2) {
			if (!containsWholeWord(timeSegment, DURATION_FLAG_TO)) {
				throw new InvalidInputFormatException(ERROR_MESSAGE_UNSUPPORTED_DATE_FORMAT);
			}
		}
	}

	/**
	 * Set the default time to 8am to avoid using system time for the task.
	 * @param timeSegment
	 * @param dates
	 * @return the modified time if applicable
	 */
	private String setDefaultTimeIfNotSpecified(String timeSegment, List<Date> dates) {
		assert timeSegment != null;
		assert dates != null;

		String parsedTime = getRoughTime(dates.toString());
		String currentSystemTime = getRoughTime(new Date().toString());

		//user has not specified a time in day hours
		if (parsedTime.equals(currentSystemTime)) {
			String timeResult = timeParser.parse(
					timeSegment + STRING_WHITE_SPACE + DEFAULT_TIME).toString();
			return timeResult;
		}

		//user has specified a time in day hours
		else {
			return dates.toString();
		}
	}

	/**
	 * Determine the approximate time for comparsion.
	 * @param fullDate
	 * @return the approximate time
	 */
	private String getRoughTime(String fullDate) {
		assert fullDate != null;
		return fullDate.substring(fullDate.indexOf(TIME_SEPARATOR) - 2, 
				fullDate.indexOf(TIME_SEPARATOR, fullDate.indexOf(TIME_SEPARATOR) + 1) + 2);
	}


	/**
	 * @param formattedCommandContent
	 * @return the time segment from the formatted command content
	 */
	private String determineTimeSegment(String formattedCommandContent) {
		assert formattedCommandContent != null;

		int timeIndex = getStartingIndexOfIdentifier(formattedCommandContent);
		int priorityIndex = getStartingIndexOfPriority(formattedCommandContent);
		String timeSegment;

		//no time is specified
		if (timeIndex == FIELD_NOT_EXIST) {
			timeSegment = STRING_EMPTY;
		}

		//time is specified but priority is not specified
		else if (priorityIndex == FIELD_NOT_EXIST) {
			timeSegment = formattedCommandContent.substring(timeIndex);
		}

		//both time and priority are specified
		else {
			timeSegment = formattedCommandContent.substring(timeIndex, priorityIndex - 1);
		}
		timeSegment = formatTimeSegment(timeSegment);
		return timeSegment;
	}

	/**
	 * Fix the case where "on" is followed by "from ... to ..."
	 * which is not handled properly by the PrettyTimeParser library.
	 * @param timeSegment
	 * @return
	 */
	private String formatTimeSegment(String timeSegment) {
		assert timeSegment != null;

		if (containsWholeWord(timeSegment, EVENT_FLAG_ON) 
				&& containsWholeWord(timeSegment, DURATION_FLAG_FROM )){

			timeSegment = timeSegment.replaceAll(DURATION_FLAG_FROM, 
					STRING_EMPTY);
			timeSegment = removeTrailingSpaces(timeSegment);
		}

		return timeSegment;
	}

	/**
	 * @param formattedCommandContent
	 * @return priority of the task
	 * @throws InvalidInputFormatException
	 */
	protected String determinePriority(String formattedCommandContent) 
			throws InvalidInputFormatException {
		assert formattedCommandContent != null;

		//priority is specified
		if (formattedCommandContent.contains(PRIORITY_FLAG)) {
			String priority = formattedCommandContent.substring(
					formattedCommandContent.indexOf(PRIORITY_FLAG) + 1).trim();
			priority = priority.toLowerCase();

			//check validity of input priority
			if (!isValidPriority(priority)) {
				throw new InvalidInputFormatException(
						ERROR_MESSAGE_INVALID_PRIORITY);
			}

			//convert aliases to standard priority
			return getPriorityInFull(priority);
		}

		//priority is not specified
		else {
			return PriorityLevel.NOT_SPECIFIED.getType();
		}
	}

	/**
	 * Check whether the specified priority is valid.
	 * Return true for valid priority or false otherwise.
	 * @param priority
	 * @return true or false
	 */
	private boolean isValidPriority(String priority) {
		assert priority != null;

		if (priority.equals(PriorityLevel.HIGH.getType()) 
				|| priority.equals(PriorityLevel.MEDIUM.getType()) 
				|| priority.equals(PriorityLevel.LOW.getType()) 
				|| priority.equals(ALIAS_PRIORITY_HIGH) 
				|| priority.equals(ALIAS_1_PRIORITY_MEDIUM) 
				|| priority.equals(ALIAS_2_PRIORITY_MEDIUM) 
				|| priority.equals(ALIAS_PRIORITY_LOW)) {
			return true;
		}

		else {
			return false;
		}
	}

	/**
	 * Convert the aliases for valid priority level to the standard forms.
	 * @param priority
	 * @return the priority in full
	 */
	private String getPriorityInFull(String priority) {
		assert priority != null;

		if (priority.equals(PriorityLevel.HIGH.getType()) 
				|| priority.equals(ALIAS_PRIORITY_HIGH)) {
			priority = PriorityLevel.HIGH.getType();
		}

		else if (priority.equals(PriorityLevel.MEDIUM.getType()) 
				|| priority.equals(ALIAS_1_PRIORITY_MEDIUM) 
				|| priority.equals(ALIAS_2_PRIORITY_MEDIUM)) {
			priority = PriorityLevel.MEDIUM.getType();
		}

		else if (priority.equals(PriorityLevel.LOW.getType()) ||
				priority.equals(ALIAS_PRIORITY_LOW)) {
			priority = PriorityLevel.LOW.getType();
		}

		return priority;
	}

	/**
	 * @param formattdCommandContent
	 * @return type of the task
	 */
	protected String determineTaskType(String formattedCommandContent) {
		assert formattedCommandContent != null;

		int timeIndex = getStartingIndexOfIdentifier(formattedCommandContent);
		String timeSegment = determineTimeSegment(formattedCommandContent).toLowerCase();

		//time is not specified
		if (timeIndex == FIELD_NOT_EXIST) {
			return TaskType.EVENT.getType();
		}

		//time is in the format "from... to..."
		else if (isDurationTask(timeSegment)) {
			return TaskType.DURATION.getType();
		}

		//time is specified by a single date with no duration
		else {
			//time is specified by "by" and "before"
			if (formattedCommandContent.substring(timeIndex, timeIndex + 2)
					.equalsIgnoreCase(DEADLINE_FLAG_BY)|| formattedCommandContent.substring(
							timeIndex, timeIndex + 6).equalsIgnoreCase(DEADLINE_FLAG_BEFORE)) {
				return TaskType.DEADLINE.getType();
			}

			//time is specified by any other allowed prepositions or phrases
			else {
				return TaskType.EVENT.getType();
			}
		}
	}

	/**
	 * Check whether the whole keyword is contained in content.
	 * Return true if it is contained or false otherwise.
	 * @param content
	 * @param keyword
	 * @return true or false
	 */
	private boolean containsWholeWord(String content, String keyword) {
		assert content != null;
		assert keyword != null;

		String[] segments = content.split(STRING_WHITE_SPACE);  
		for (int i = 0; i < segments.length; i++) {
			if (segments[i].equalsIgnoreCase(keyword)) {
				return true;
			}
		}

		return false;
	}

	/**
	 * Check whether the task is a task which spans over a period of time.
	 * Return true if it is or false otherwise.
	 * @param timeSegment
	 * @return true or false
	 */
	private boolean isDurationTask(String timeSegment) {
		assert timeSegment != null;

		if (timeParser.parse(timeSegment).size() == 2 
				&& (containsWholeWord(timeSegment, DURATION_FLAG_FROM)
						|| containsWholeWord(timeSegment, DURATION_FLAG_TO))) {
			return true;
		}

		else {
			return false;
		}
	}

	/**
	 * @param timeSegment
	 * @return status of the task
	 */
	protected String determineStatus(String timeSegment) {
		assert timeSegment != null;

		//parse the time
		List<Date> dates = timeParser.parse(timeSegment);
		int size = dates.size();

		//no time is specified for the task
		if (size == 0) {
			return TASK_FLOATING;
		}

		//the task is overdue on adding
		else if (isOverdue(dates.get(size - 1)) && (!isToday(dates))) {
			return TASK_OVERDUE;
		}

		//time is specified for the task
		else {
			return TASK_UPCOMING;
		}
	}


	/**
	 * Check whether the time is today.
	 * Return true if it is or false otherwise.
	 * @param dates
	 * @return true or false
	 */
	private boolean isToday(List<Date> dates) {
		assert dates != null;
		return dates.toString().substring(1,11).equals
				(new Date().toString().substring(0, 10));
	}

	/**
	 * Determine the starting index of a whole word appeared in the content.
	 * @param content
	 * @param expression
	 * @return the starting index of the word
	 */
	private int getIndexOfWholeWord(String content, String expression) {
		assert content != null;
		assert expression != null;

		content = content.toLowerCase();
		String[] segments = content.split(STRING_WHITE_SPACE);
		int size = segments.length;
		int index = FIELD_NOT_EXIST;
		int finalIndex = 0;

		//determine the index of expression in segments
		for (int i = 0; i < size; i++) {
			if (segments[i].equals(expression)) {
				index = i;
			}
		}

		//recalculate the finalIndex in content based on the index in segments
		if (index != FIELD_NOT_EXIST) {
			for (int i = 0; i < index; i++) {
				finalIndex += segments[i].length() + 1;
			}
		}

		return finalIndex;
	}

	/**
	 * Add a preposition to the time segment for easy parsing if needed.
	 * @param commandContent
	 * @param timePhrase
	 * @return the modified command content
	 */
	private String addPrepositionIfApplicable(String commandContent, String timePhrase) {
		assert commandContent != null;
		assert timePhrase != null;

		//contains the particular time phrase
		if (containsWholeWord(commandContent, timePhrase)) {

			//time phrase is the first word
			if (getIndexOfWholeWord(commandContent, timePhrase) == 0) {
				commandContent = formatWithTimePhraseAsFirstWord(commandContent, timePhrase);
			}

			//time phrase is not the first word
			else {
				commandContent = formatWithTimePhraseNotAsFirstWord
						(commandContent, timePhrase);

			}
		}

		return commandContent;
	}

	/**
	 * @param commandContent
	 * @param timePhrase
	 * @return the formatted command content
	 */
	private String formatWithTimePhraseNotAsFirstWord(String commandContent, 
			String timePhrase) {
		assert commandContent != null;
		assert timePhrase != null;

		//determine the position of timePhrase
		String[] segments = commandContent.split(STRING_WHITE_SPACE);
		int index = determineIndexOfTimePhrase(segments, timePhrase);
		int len = segments.length;

		//no valid preposition before time phrase
		if (!isValidTimeIdentifier(segments[index - 1])) {

			//time phrase is the last word
			if (index + 1 == len) {
				commandContent = formatWithTimePhraseAsLastWord(segments, index);
			}

			//time phrase is not the last word, and no valid preposition after time phrase
			else if (index + 1 < len && 
					!isValidTimeIdentifier(segments[index + 1])) {
				commandContent = formatWithTimePhraseNotAsLastWordWithNoValidFollowingPrepositon(
						segments, index);
			}

			//time phrase is not the last word, and valid preposition after time phrase
			else if (index + 1 < len 
					&& isValidTimeIdentifier(segments[index + 1])) {
				commandContent = formatWithTimePhraseNotAsLastWordWithValidFollowingPreposition(
						segments, index);
			}
		}

		return commandContent;
	}

	/**
	 * @param segments
	 * @param index
	 * @return formatted command content
	 */
	private String formatWithTimePhraseNotAsLastWordWithValidFollowingPreposition(
			String[] segments, int index) {
		assert segments != null;

		//retrieve the content before the time phrase
		String newContent = STRING_EMPTY;
		for (int i = 0; i < index; i++) {
			newContent += segments[i] + STRING_WHITE_SPACE;
		}

		//retrieve the rest of the command content
		String rest = STRING_EMPTY;
		for (int i = index + 2; i < segments.length; i++) {
			rest += STRING_WHITE_SPACE + segments[i];
		}

		//no time phrase in rest of the command content
		if (timeParser.parse(rest).size() == 0) {
			newContent += EVENT_FLAG_ON + STRING_WHITE_SPACE + segments[index];
		}

		//time phrase present in rest of the command content
		else {
			newContent += segments[index + 1] + 
					STRING_WHITE_SPACE + segments[index];
		}

		return newContent + rest;
	}

	/**
	 * @param segments
	 * @param index
	 * @return formatted command content
	 */
	private String formatWithTimePhraseNotAsLastWordWithNoValidFollowingPrepositon(
			String[] segments, int index) {
		assert segments != null;

		//retrieve the content before the time phrase
		String newContent = STRING_EMPTY;
		for (int i = 0; i < index; i++) {
			newContent += segments[i] + STRING_WHITE_SPACE;
		}

		//append the preposition to newContent
		newContent += EVENT_FLAG_ON + STRING_WHITE_SPACE + segments[index];

		//append rest of the command content to newContent
		for (int i = index + 1; i < segments.length; i++) {
			newContent += STRING_WHITE_SPACE + segments[i];
		}
		return newContent;
	}

	/**
	 * @param segments
	 * @param index
	 * @return formatted command content
	 */
	private String formatWithTimePhraseAsLastWord(String[] segments, int index) {
		assert segments != null;

		String newContent = STRING_EMPTY;
		for (int i = 0; i < index; i++) {
			newContent += segments[i] + STRING_WHITE_SPACE;
		}

		//append the preposition to newContent
		newContent += EVENT_FLAG_ON + STRING_WHITE_SPACE + segments[index];

		return newContent;
	}

	/**
	 * @param segments
	 * @param timePhrase
	 * @return the starting index of the time phrase
	 */
	private int determineIndexOfTimePhrase(String[] segments, String timePhrase) {
		assert segments != null;
		assert timePhrase != null;

		int index = 0;
		for (int i = 0; i < segments.length; i++) {
			if (segments[i].equals(timePhrase)) {
				index = i;
				break;
			}
		}
		return index;
	}

	/**
	 * @param commandContent
	 * @param timePhrase
	 * @return the formatted command content
	 */
	private String formatWithTimePhraseAsFirstWord(String commandContent, String timePhrase) {
		assert commandContent != null;
		assert timePhrase != null;

		int startIndex = commandContent.indexOf(STRING_WHITE_SPACE) + 1;
		String nextWord = commandContent.substring(startIndex);

		//check if there is still content after time phrase
		if (nextWord.indexOf(STRING_WHITE_SPACE) != -1) {
			nextWord = nextWord.substring(
					0, nextWord.indexOf(STRING_WHITE_SPACE));
		}

		//there is a valid preposition following time phrase
		if (startIndex < commandContent.length() 
				&& isValidTimeIdentifier(nextWord)) {

			commandContent = commandContent.substring(startIndex);

			commandContent = formatWithValidFollowingPreposition(
					commandContent, timePhrase);
		}

		//no preposition after time phrase
		else {

			commandContent = EVENT_FLAG_ON + STRING_WHITE_SPACE + commandContent;
		}

		return commandContent;
	}

	/**
	 * @param commandContent
	 * @param timePhrase
	 * @return the formatted command content
	 */
	private String formatWithValidFollowingPreposition(
			String commandContent, String timePhrase) {
		assert commandContent != null;
		assert timePhrase != null;

		//no time phrase in rest of the command content
		if (timeParser.parse(commandContent).size() == 0) {
			commandContent = EVENT_FLAG_ON + STRING_WHITE_SPACE + timePhrase 
					+ STRING_WHITE_SPACE + commandContent;
		}

		//other time phrases present in rest of the command content
		else {
			int index = commandContent.indexOf(STRING_WHITE_SPACE) + 1;
			commandContent = commandContent.substring(0, index) + timePhrase 
					+ STRING_WHITE_SPACE + commandContent.substring(index);
		}

		return commandContent;
	}

	/**
	 * Format the command content to the standardized format:
	 * task-time-priority to facilitate parsing later.
	 * @param content
	 * @return the formatted command content
	 */
	protected String formatToStandardCommandContent(String content) {
		assert content != null;

		String formattedContent = preFormat(content);
		int timeIndex = getStartingIndexOfIdentifier(formattedContent);
		int priorityIndex = getStartingIndexOfPriority(formattedContent);
		int taskIndex = getStartingIndexOfTask(formattedContent, timeIndex, priorityIndex);

		//task only
		if (timeIndex == FIELD_NOT_EXIST && priorityIndex == FIELD_NOT_EXIST) {
			return formattedContent;
		}

		//no time,has priority
		else if (timeIndex == FIELD_NOT_EXIST) {
			return formatWithNoTimeSegment(formattedContent, taskIndex, priorityIndex);
		}

		//no priority,has time
		else if (priorityIndex == FIELD_NOT_EXIST) {
			return formatWithNoPrioritySegment(formattedContent, taskIndex, timeIndex);	
		}

		//time,priority and maybe task
		else {

			//no task
			if (taskIndex == FIELD_NOT_EXIST) {
				return formatWithNoTaskPresent(formattedContent, 
						timeIndex, priorityIndex);
			}

			//task is present
			else {
				return formatWithTaskPresent(formattedContent, 
						taskIndex, timeIndex, priorityIndex);
			}
		}
	}


	/**
	 * @param formattedContent
	 * @param timeIndex
	 * @param priorityIndex
	 * @return the formatted content
	 */
	private String formatWithNoTaskPresent(String formattedContent, 
			int timeIndex, int priorityIndex) {
		assert formattedContent != null;

		//priority followed by time
		if (timeIndex > priorityIndex) {
			return formattedContent.substring(timeIndex)+ STRING_WHITE_SPACE + 
					formattedContent.substring(0, timeIndex - 1);
		}

		//time followed by priority
		else {
			return formattedContent;
		}
	}

	/**
	 * @param formattedContent
	 * @param taskIndex
	 * @param timeIndex
	 * @param priorityIndex
	 * @return the formatted content
	 */
	private String formatWithTaskPresent(String formattedContent, int taskIndex, 
			int timeIndex, int priorityIndex) {
		assert formattedContent != null;

		//task is the first segment
		if (taskIndex < timeIndex && taskIndex < priorityIndex) {
			return formatWithTaskAsFirstSegment(formattedContent, taskIndex, 
					timeIndex, priorityIndex);
		}

		//priority-task-time
		else if (taskIndex < timeIndex) {
			return formattedContent.substring(taskIndex) + STRING_WHITE_SPACE +
					formattedContent.substring(priorityIndex,taskIndex - 1);
		}

		//time-task-priority
		else if (taskIndex < priorityIndex) {
			return formattedContent.substring(taskIndex, priorityIndex - 1) + 
					STRING_WHITE_SPACE + formattedContent.substring(
							timeIndex, taskIndex - 1) + STRING_WHITE_SPACE 
					+ formattedContent.substring(priorityIndex);
		}

		//task is the last segment
		else {
			return formatWithTaskAsLastSegment(formattedContent, taskIndex, 
					timeIndex, priorityIndex);
		}
	}

	/**
	 * @param formattedContent
	 * @param taskIndex
	 * @param timeIndex
	 * @param priorityIndex
	 * @return the formatted content
	 */
	private String formatWithTaskAsLastSegment(String formattedContent, 
			int taskIndex, int timeIndex, int priorityIndex) {
		assert formattedContent != null;

		//time-priority-task
		if (timeIndex < priorityIndex) {
			return formattedContent.substring(taskIndex) + STRING_WHITE_SPACE 
					+ formattedContent.substring(timeIndex, priorityIndex - 1) 
					+ STRING_WHITE_SPACE + formattedContent.substring(
							priorityIndex, taskIndex - 1);
		}

		//priority-time-task
		else {
			return formattedContent.substring(taskIndex) + STRING_WHITE_SPACE 
					+ formattedContent.substring(timeIndex, taskIndex - 1) + 
					STRING_WHITE_SPACE + formattedContent.substring(
							priorityIndex, timeIndex - 1);
		}
	}

	/**
	 * @param formattedContent
	 * @param taskIndex
	 * @param timeIndex
	 * @param priorityIndex
	 * @return the formatted content
	 */
	private String formatWithTaskAsFirstSegment(String formattedContent, 
			int taskIndex, int timeIndex, int priorityIndex) {
		assert formattedContent != null;

		//task-time-priority
		if (timeIndex < priorityIndex) {
			return formattedContent;
		}

		//task-priority-time
		else {
			return formattedContent.substring(taskIndex,priorityIndex) + 
					formattedContent.substring(timeIndex) + STRING_WHITE_SPACE + 
					formattedContent.substring(priorityIndex,timeIndex - 1);
		}
	}

	/**
	 * @param formattedContent
	 * @param taskIndex
	 * @param timeIndex
	 * @return formatted content
	 */
	private String formatWithNoPrioritySegment(String formattedContent, 
			int taskIndex, int timeIndex) {
		assert formattedContent != null;

		//only time
		if (taskIndex == FIELD_NOT_EXIST) {
			return formattedContent;
		}

		//task and time
		else {

			//time followed by task
			if (taskIndex > timeIndex) {
				return formattedContent.substring(taskIndex)+ STRING_WHITE_SPACE + 
						formattedContent.substring(0, taskIndex - 1);
			}

			//task followed by time
			else {
				return formattedContent;
			}
		}
	}

	/**
	 * @param formattedContent
	 * @param taskIndex
	 * @param priorityIndex
	 * @return formatted content
	 */
	private String formatWithNoTimeSegment(String formattedContent, int taskIndex, 
			int priorityIndex) {
		assert formattedContent != null;

		//only priority
		if (taskIndex == FIELD_NOT_EXIST) {
			return formattedContent;
		}

		//priority and task
		else {

			//priority followed by task
			if (taskIndex > priorityIndex) {
				return formattedContent.substring(taskIndex)+ STRING_WHITE_SPACE + 
						formattedContent.substring(0, taskIndex - 1);
			}

			//task followed by priority
			else {
				return formattedContent;
			}
		}
	}

	/**
	 * Format the content for easy parsing.
	 * @param content
	 * @return formatted content
	 */
	private String preFormat(String content) {
		assert content != null;

		content = removeTrailingSpaces(content);
		content = handleTimeWithoutPreposition(content);
		return content;
	}

	/**
	 * @param commandContent
	 * @return formatted command content
	 */
	private String handleTimeWithoutPreposition(String commandContent) {
		assert commandContent != null;

		//format "tmr" to "tomorrow"
		commandContent = commandContent.replaceAll(TOMORROW_IN_SHORT, TOMORROW_IN_FULL);

		//handle the "now" keyword
		if (isNecessaryToAddPrepostion(commandContent, STRING_NOW)) {
			commandContent = addPrepositionIfApplicable(commandContent, STRING_NOW);
		}

		//handle the "today" keyword
		else if (isNecessaryToAddPrepostion(commandContent, STRING_TODAY)) {
			commandContent = addPrepositionIfApplicable(commandContent, STRING_TODAY);
		}

		//handle the "tomorrow" keyword
		else if (isNecessaryToAddPrepostion(commandContent, TOMORROW_IN_FULL)) {
			commandContent = addPrepositionIfApplicable(commandContent, TOMORROW_IN_FULL);
		}

		return commandContent;
	}

	/**
	 * @param content
	 * @return trimmed content
	 */
	private String removeTrailingSpaces(String content) {
		assert content != null;
		content = content.replaceAll(EXTRA_WHITE_SPACES, STRING_WHITE_SPACE).trim();
		return content;
	}

	/**
	 * Check whether it is needed to add a preposition the command content.
	 * Return true if it is needed or false otherwise.
	 * @param content
	 * @param timePhrase
	 * @return true or false
	 */
	private boolean isNecessaryToAddPrepostion(String content, String timePhrase) {
		assert content != null;
		assert timePhrase != null;

		int index = content.indexOf(timePhrase);

		//the time phrase is in quotes
		if (containsWholeWord(content, QUOTATION + timePhrase + QUOTATION)) {
			return false;
		}

		//there is no such time phrase
		else if (index == FIELD_NOT_EXIST) {
			return false;
		}

		//there is such time phrase
		else {
			String front = content.substring(0,index).trim();

			//valid time phrase
			if (timeParser.parse(front).toString().equals(TIME_EMPTY)) {
				return true;
			}

			//invalid time phrase
			else {
				return false;
			}
		}

	}


	/**
	 * @param content
	 * @return the starting index of the priority segment
	 */
	private int getStartingIndexOfPriority(String content) {
		return content.indexOf(PRIORITY_FLAG);
	}


	/**
	 * @param content
	 * @param timeIndex
	 * @param priorityIndex
	 * @return the starting index of the task segment
	 */
	private int getStartingIndexOfTask(String content, int timeIndex, int priorityIndex) {
		assert content != null;

		//no time or priority -> only task
		if (timeIndex == FIELD_NOT_EXIST && priorityIndex == FIELD_NOT_EXIST) {
			return 0;
		}

		//no time, has priority -> priority-task/task-priority/priority
		else if (timeIndex == FIELD_NOT_EXIST) {
			return getStartingIndexOfTaskWithNoTimeSegment(content);
		}

		//no priority, has time -> time-task/task-time/time
		else if (priorityIndex == FIELD_NOT_EXIST) {
			return getStartingIndexOfTaskWithNoPrioirtySegment(content, timeIndex);
		}

		//time, priority and maybe task are present
		else {
			return getStartingIndexOfTaskWithBothTimeAndPriorityPresent(
					content, timeIndex, priorityIndex);
		}
	}

	/**
	 * @param content
	 * @param timeIndex
	 * @param priorityIndex
	 * @return the starting index of the task segment
	 */
	private int getStartingIndexOfTaskWithBothTimeAndPriorityPresent(
			String content, int timeIndex, int priorityIndex) {
		assert content != null;

		//time is the first segment
		if (timeIndex == 0) {
			return getStartingIndexOfTaskWithTimeAsFirstSegment(content, priorityIndex);

		}

		//priority is the first segment
		else if (priorityIndex == 0) {
			return getStartingIndexOfTaskWithPriorityAsFirstSegment(content, timeIndex);

		}

		//task is the first segment
		else {
			return 0;
		}
	}

	/**
	 * @param content
	 * @param timeIndex
	 * @return the starting index of the task segment
	 */
	private int getStartingIndexOfTaskWithPriorityAsFirstSegment(
			String content, int timeIndex) {
		assert content != null;

		//priority-time or priority-time-task
		if (timeIndex == content.indexOf(STRING_WHITE_SPACE) + 1) {
			int baseIndex = content.indexOf(STRING_WHITE_SPACE) + 1;
			String segment = content.substring(baseIndex);
			int index = locateTaskIndexInSegment(segment);

			//priority-time
			if (index == FIELD_NOT_EXIST) {
				return FIELD_NOT_EXIST;
			}

			//priority-time-task
			else {
				return baseIndex + index;
			}
		}

		//priority-task-time
		else {
			return content.indexOf(STRING_WHITE_SPACE) + 1;
		}
	}

	/**
	 * @param content
	 * @param priorityIndex
	 * @return the starting index of task segment
	 */
	private int getStartingIndexOfTaskWithTimeAsFirstSegment(
			String content, int priorityIndex) {
		assert content != null;

		//time-priority-task
		if (priorityIndex < content.lastIndexOf(STRING_WHITE_SPACE)) {
			return content.indexOf(STRING_WHITE_SPACE,content.indexOf
					(PRIORITY_FLAG)) + 1;
		}

		//time-task-priority or time-priority
		else {
			String segment = content.substring(0,content.indexOf
					(PRIORITY_FLAG) - 1);
			return locateTaskIndexInSegment(segment);
		}	
	}

	/**
	 * @param content
	 * @param timeIndex
	 * @return the starting index of the task segment
	 */
	private int getStartingIndexOfTaskWithNoPrioirtySegment(
			String content, int timeIndex) {
		assert content != null;

		//<time>/<time-task>
		if (timeIndex == 0) {
			return locateTaskIndexInSegment(content);	
		}

		//task-time
		else {
			return 0;
		}	
	}

	/**
	 * @param content
	 * @return the starting index of the task segment
	 */
	private int getStartingIndexOfTaskWithNoTimeSegment(String content) {
		assert content != null;

		//priority
		if (!content.contains(STRING_WHITE_SPACE)) {
			return FIELD_NOT_EXIST;
		}

		else {

			//priority-task
			if (content.substring(0,1).equals(PRIORITY_FLAG)) {
				return content.indexOf(STRING_WHITE_SPACE) + 1;
			}

			//task-priority
			else {
				return 0;
			}
		}
	}

	/**
	 * @param content
	 * @return the starting index of task segment in the found segment
	 */
	private int locateTaskIndexInSegment(String content) {
		assert content != null;

		//input: time/time-task
		int count = StringUtils.countMatches(content, STRING_WHITE_SPACE);

		//no task present
		if (count == 1) {
			return FIELD_NOT_EXIST;
		}

		//task present
		else {
			int taskIndex = getTaskIndex(content, count);
			return taskIndex;
		}
	}


	/**
	 * @param content
	 * @param count
	 * @return the index of the task based on the count of appearances
	 */
	private int getTaskIndex(String content, int count) {
		assert content != null;

		//initialize to not-exist at first
		int taskIndex = FIELD_NOT_EXIST;

		//determine the task index if task is present
		String oldDate = getRoughDate(timeParser.parse(content).toString());
		for (int i = 2; i <= count; i++) {

			//get the newDate by taking in one more word
			int index = StringUtils.ordinalIndexOf(content, STRING_WHITE_SPACE, i);
			String newDate = content.substring(0, index);
			newDate = timeParser.parse(newDate).toString();

			//time is not present
			if (!newDate.equals(TIME_EMPTY)) {
				newDate = getRoughDate(newDate);
			}

			//stop when newDate and oldDate are the same
			if (newDate.equals(oldDate)) {
				taskIndex = index + 1;
				break;
			}
		}

		return taskIndex;

	}

	/**
	 * Determine the starting index of time identifer to locate the time phrase.
	 * @param content
	 * @return the starting index of the time identifier
	 */
	private int getStartingIndexOfIdentifier(String content) {
		assert content != null;

		//a queue to store starting indices of the possible identifiers
		PriorityQueue<Integer> indexQueue;
		indexQueue = buildIndexQueue(content);

		//a list to store the indices in reversed order
		ArrayList<Integer> list;
		list = buildIndexListInReversedOrder(indexQueue);

		//no identifier -> no time phrase present
		if (list.size() == 0) {
			return FIELD_NOT_EXIST;
		}

		//only one match
		else if (list.size() == 1) {
			return getStartingIndexOfIdentifierWithOneMatch(content, list);
		}

		//there are possible matches
		else if (list.size() == 2) {
			return getStartingIndexOfIdentiferWithTwoMatches(content, list);
		}

		//list size is at least 3 -> check substrings to determine
		else {
			return getStartingIndexOfIdentifierWithMoreThanTwoMatches(content, list);
		}

	}

	/**
	 * @param content
	 * @param list
	 * @return the starting index of the time identifier
	 */
	private int getStartingIndexOfIdentifierWithMoreThanTwoMatches(String content, 
			ArrayList<Integer> list) {
		assert content != null;
		assert list != null;

		for (int i = 0; i < list.size(); i++) {

			//i is not the last index stored
			if (i < list.size() - 1) {
				String substring = content.substring(list.get(i),list.get(i + 1));

				//i is the starting index of the valid identifier
				if (!timeParser.parse(substring).toString().equals(TIME_EMPTY)) {
					return list.get(i);
				}
			}

			//i is the last index stored
			else {
				String substring = content.substring(list.get(i));

				//i is the starting index of the valid identifier
				if (!timeParser.parse(substring).toString().equals(TIME_EMPTY)) {
					return list.get(i);
				}
			}
		}

		//not valid identifier is found
		return FIELD_NOT_EXIST;
	}

	/**
	 * @param content
	 * @param list
	 * @return starting index of the time identifier
	 */
	private int getStartingIndexOfIdentiferWithTwoMatches(String content, 
			ArrayList<Integer> list) {
		assert content != null;
		assert list != null;

		//first one is valid
		if (!timeParser.parse(content.substring(list.get(0), list.get(1)))
				.toString().equals(TIME_EMPTY)) {
			return list.get(0);
		}

		//second one is valid
		else if (!timeParser.parse(content.substring(list.get(1)))
				.toString().equals(TIME_EMPTY)) {
			return list.get(1);
		}

		//both are invalid
		else {
			return FIELD_NOT_EXIST;
		}
	}

	/**
	 * @param content
	 * @param list
	 * @return starting index of the time identifier
	 */
	private int getStartingIndexOfIdentifierWithOneMatch(String content, 
			ArrayList<Integer> list) {
		assert content != null;
		assert list != null;

		//it is valid
		if (!timeParser.parse(content).toString().equals(TIME_EMPTY)) {
			return list.get(0);
		}

		//it is invalid
		else {
			return FIELD_NOT_EXIST;
		}
	}

	/**
	 * @param indexQueue
	 * @return the indices of time identifiers in the list in reversed order
	 */
	private ArrayList<Integer> buildIndexListInReversedOrder(
			PriorityQueue<Integer> indexQueue) {
		assert indexQueue != null;

		ArrayList<Integer> list = new ArrayList<Integer>();
		int size = indexQueue.size();
		for (int i = 0; i < size; i++) {
			list.add(indexQueue.poll());
		}

		return list;
	}

	/**
	 * @param content
	 * @return the indices of time identifiers in the list
	 */
	private PriorityQueue<Integer> buildIndexQueue(String content) {
		assert content != null;

		//get the number of words in content
		String[] segments = content.split(STRING_WHITE_SPACE);
		int numberOfSpaces = segments.length - 1;

		PriorityQueue<Integer> indexQueue = new PriorityQueue<Integer>();

		//a pointer to move along all words
		int pointer = 0;
		for (int i = 1; i <= numberOfSpaces; i++) {
			int index = StringUtils.ordinalIndexOf(content, STRING_WHITE_SPACE, i);

			//put the index in if the word is a possible identifier
			if (isValidTimeIdentifier(content.substring(pointer, index))) {
				indexQueue.offer(pointer);
			}

			//move to the next word
			pointer = index + 1;
		}

		return indexQueue;
	}

	/**
	 * Check whether the time identifier is valid.
	 * Return true if it is valid or false otherwise.
	 * @param content
	 * @return true or false
	 */
	private boolean isValidTimeIdentifier(String content) {
		assert content != null;
		String word = content.toLowerCase();

		if (word.equals(DEADLINE_FLAG_BY)) {
			return true;
		}
		else if (word.equals(DEADLINE_FLAG_BEFORE)) {
			return true;
		}

		else if (word.equals(EVENT_FLAG_AT)) {
			return true;
		}

		else if (word.equals(EVENT_FLAG_ON)) {
			return true;
		}

		else if (word.equals(DURATION_FLAG_FROM)) {
			return true;
		}

		else{
			return false;
		}
	}

	/**
	 * @param time
	 * @return true or false
	 */
	private boolean isOverdue(Date date) {
		assert date != null;
		return date.before(new Date());
	}

	/**
	 * @param time
	 * @return the approximate date
	 */
	private String getRoughDate(String time) {
		assert time != null;

		String[] segments = time.split(TIME_SEPARATOR);
		time = segments[0] + segments[1] + segments[2].substring(2);
		return time;
	}
}
```
###### main\java\parser\AddCommandParser.java
``` java

```
###### main\java\parser\DeleteCommandParser.java
``` java
package main.java.parser;

import main.java.exception.InvalidInputFormatException;

/**
 * This class parses the delete command.
 * @author Ouyang Danwen
 *
 */
public class DeleteCommandParser {
	
	/* error messages used in this class */
	private static final String ERROR_MESSAGE_DELETE_NOTHING = ""
			+ "Please specify a task to delete!";
	
	/* numeric constans to access the parameters array*/
	private static final int TASK = 0;
	
	/**
	 * Empty constructor.
	 */
	public DeleteCommandParser() {}

	/**
	 * @param commandContent
	 * @return the command parameters as a string array
	 * @throws InvalidInputFormatException
	 */
	public String[] determineParameters(String commandContent) 
			throws InvalidInputFormatException {
		assert commandContent != null;
		
		
		String[] parameters = new String[5];
		
		if (commandContent.isEmpty()) {
			throw new InvalidInputFormatException(ERROR_MESSAGE_DELETE_NOTHING);
		}
		
		else {
			parameters[TASK] = commandContent;

		}
		
		return parameters;
	}

}
```
###### main\java\parser\DeleteCommandParser.java
``` java

```
###### main\java\parser\EditCommandParser.java
``` java
package main.java.parser;

/* import statements */
import java.util.ArrayList;

import main.java.data.Task;
import main.java.data.TransientTask;
import main.java.exception.InvalidInputFormatException;
import main.java.data.Command;

/**
 * This class parses the edit command.
 * @author Ouyang Danwen
 *
 */
public class EditCommandParser extends AddCommandParser {
	
	/* error messages */
	private static final String ERROR_MESSAGE_EDIT_NOTHING = ""
			+ "Please specify a task to be edited!";
	private static final String ERROR_MESSAGE_INVALID_EDIT_COMMAND = ""
			+ "Please use \",\" to separate!";
	private static final String ERROR_MESSAGE_UPDATE_NOTHING = ""
			+ "Please specifiy update information!";
	
	/* string constants used in this class */
	private static final String EMPTY_STRING = "";
	private static final String EDIT_COMMAND_SEPARATOR = ",";
	private static final String EDIT_TASK_SEPARATOR = " , ";
	private static final String ALTERNATIVE_EDIT_TASK_SEPARATOR = "%";
	
	/* numeric indices to access the parameters array */
	private static final int TASK = 0;
	private static final int TIME = 1;
	private static final int PRIORITY = 2;
	private static final int TASK_TYPE = 3;
	private static final int STATUS = 4;
	
	/**
	 * Empty constructor.
	 */
	public EditCommandParser() {}

	/**
	 * This override method determines the parameters for the edit command.
	 * @param commandContent
	 * @throws InvalidInputFormatException
	 * @return the determined parameters as a string array
	 */
	@Override
	public String[] determineParameters(String commandContent) 
			throws InvalidInputFormatException {
		assert commandContent != null;
		
		//check validity of the edit command
		checkAndHandleInvalidCommand(commandContent);
		
		//split the two parts of an edit command
		String[] segments = commandContent.split(EDIT_COMMAND_SEPARATOR);
		
		//determine and set the parameters of the edit command
		String[] parameters = new String[5];
		parameters[TASK] = determineTaskForEditCommand(segments);
		parameters[TIME] = determineTimeForEditCommand(segments);
		parameters[PRIORITY] = determinePriorityForEditCommand(segments);
		parameters[TASK_TYPE] = determineTaskTypeForEditCommand(segments);
		parameters[STATUS] = determineStatusForEditCommand(segments);
		
		return parameters;
	}

	/**
	 * Handle all the invalid commands by throwing exceptions.
	 * @param commandContent
	 * @throws InvalidInputFormatException
	 */
	private void checkAndHandleInvalidCommand(String commandContent) 
			throws InvalidInputFormatException {
		assert commandContent != null;
		
		//empty command is not allowed
		if (commandContent.isEmpty()) {
			throw new InvalidInputFormatException(ERROR_MESSAGE_INVALID_EDIT_COMMAND);
		}
		
		//invalid command if the separator comma is not present
		else if (commandContent.indexOf(EDIT_COMMAND_SEPARATOR) == -1) {
			throw new InvalidInputFormatException(ERROR_MESSAGE_INVALID_EDIT_COMMAND);
		}
		
		//invalid command if no task is specified to edit
		else if (commandContent.indexOf(EDIT_COMMAND_SEPARATOR) == 0) {
			throw new InvalidInputFormatException(ERROR_MESSAGE_EDIT_NOTHING);
		}
		
		//invalid command if no update information is provided
		else if (commandContent.indexOf(EDIT_COMMAND_SEPARATOR) 
				== commandContent.length() - 1) {
			throw new InvalidInputFormatException(
					ERROR_MESSAGE_UPDATE_NOTHING);
		}
	}

	/**
	 * @param segments
	 * @return the task of the edit command
	 * @throws InvalidInputFormatException
	 */
	private String determineTaskForEditCommand(String[] segments) 
			throws InvalidInputFormatException {
		assert segments != null;

		String task_A = determineTask(formatToStandardCommandContent(segments[0].trim())); 
		String task_B = determineTask(formatToStandardCommandContent(segments[1].trim()));

		//no new task name to be updated -> retain the original task name
		if (task_B.equals(EMPTY_STRING)) {
			return task_A + EDIT_TASK_SEPARATOR + task_A;
		}

		//new task name is provided -> update accordingly
		else {
			return task_A + EDIT_TASK_SEPARATOR + task_B;
		}
	}

	/**
	 * @param segments
	 * @return the time of the edit command
	 * @throws InvalidInputFormatException
	 */
	private String determineTimeForEditCommand(String[] segments) 
			throws InvalidInputFormatException {
		assert segments != null;
		
		String time_A = determineTime(formatToStandardCommandContent(segments[0].trim())); 
		String time_B = determineTime(formatToStandardCommandContent(segments[1].trim()));
		
		return time_A + EDIT_TASK_SEPARATOR + time_B;

	}

	/**
	 * @param segments
	 * @return the priority of the edit command
	 * @throws InvalidInputFormatException
	 */
	private String determinePriorityForEditCommand(String[] segments) 
			throws InvalidInputFormatException {
		assert segments != null;
		
		String priority_A = determinePriority(
				formatToStandardCommandContent(segments[0].trim())); 
		String priority_B = determinePriority(
				formatToStandardCommandContent(segments[1].trim()));

		return priority_A + EDIT_TASK_SEPARATOR + priority_B;
	}


	/**
	 * @param segments
	 * @return the task type of the edit command
	 */
	private String determineTaskTypeForEditCommand(String[] segments) {
		assert segments != null;
		
		String taskType;
		taskType = determineTaskType(formatToStandardCommandContent
				(segments[0].trim())) + EDIT_TASK_SEPARATOR +
				determineTaskType(formatToStandardCommandContent
						(segments[1].trim()));
		
		return taskType;
	}

	/**
	 * @param segments
	 * @return the task status of the edit command
	 */
	private String determineStatusForEditCommand(String[] segments) {
		assert segments != null;
		
		String status;
		status = determineStatus(formatToStandardCommandContent(segments[0].trim())) 
				+ EDIT_TASK_SEPARATOR + determineStatus(
						formatToStandardCommandContent(segments[1].trim()));
		
		return status;
	}



	/**
	 * Parse the transient task to create a two task objects for editing
	 * @param transientTask
	 * @return the two parsed tasks in a task list
	 */
	public static ArrayList<Task> parseEditTask(TransientTask transientTask) {
		assert transientTask != null;
		
		//separate the information of the two tasks
		String taskName_A = transientTask.getTask().split(EDIT_COMMAND_SEPARATOR)[0].trim();
		String taskName_B = transientTask.getTask().split(EDIT_COMMAND_SEPARATOR)[1].trim();
		
		//determine the time segments for the two parsed tasks
		String time = transientTask.getTime().replaceAll(
				EDIT_TASK_SEPARATOR, ALTERNATIVE_EDIT_TASK_SEPARATOR);
		String time_A = time.split(ALTERNATIVE_EDIT_TASK_SEPARATOR)[0].trim();
		String time_B = time.split(ALTERNATIVE_EDIT_TASK_SEPARATOR)[1].trim();

		//determine the priority segments for the two parsed tasks
		String priority_A = transientTask.getPriority().split(
				EDIT_COMMAND_SEPARATOR)[0].trim();
		String priority_B = transientTask.getPriority().split(
				EDIT_COMMAND_SEPARATOR)[1].trim();
		
		//determine the type segments for the two parsed tasks
		String type_A = transientTask.getType().split(EDIT_COMMAND_SEPARATOR)[0].trim();
		String type_B = transientTask.getType().split(EDIT_COMMAND_SEPARATOR)[1].trim();

		//determine the status segments for the two parsed tasks
		String status_A = transientTask.getStatus().split(EDIT_COMMAND_SEPARATOR)[0].trim();
		String status_B = transientTask.getStatus().split(EDIT_COMMAND_SEPARATOR)[1].trim();

		//instantiate the two tasks with the parsed parameters
		Task task_A = new Task(taskName_A, Command.castTime(time_A), 
				Command.castPriority(priority_A), Command.castType(type_A), Command
				.castStatus(status_A));
	
		Task task_B = new Task(taskName_B, Command.castTime(time_B), 
				Command.castPriority(priority_B), Command.castType(type_B), Command
				.castStatus(status_B));

		//store the two parsed tasks in the resultant list to be returned
		ArrayList<Task> result = new ArrayList<Task>();
		result.add(task_A);
		result.add(task_B);
		
		return result;
	}

}
```
###### main\java\parser\EditCommandParser.java
``` java

```
###### main\java\parser\ParserTest.java
``` java
package main.java.parser;

import static org.junit.Assert.*;

import java.nio.file.InvalidPathException;
import java.nio.file.Path;
import java.nio.file.Paths;

import org.junit.Before;
import org.junit.Test;
import org.ocpsoft.prettytime.nlp.PrettyTimeParser;

import main.java.enumeration.CommandType;
import main.java.exception.InvalidInputFormatException;
import main.java.exception.NoFileNameException;

/**
 * @author Ouyang Danwen
 *
 */
public class ParserTest {
	private static AddCommandParser addParser;
	private static EditCommandParser editParser;
	private static DeleteCommandParser deleteParser;
	private static ShowCommandParser showParser;
	private static SortCommandParser sortParser;
	private static StorageCommandParser storageParser;
	private static PrettyTimeParser parser = new PrettyTimeParser();
	private static final int TASK = 0;
	private static final int TIME = 1;
	private static final int PRIORITY = 2;
	private static final int TYPE = 3;
	private static final int STATUS = 4;



	@Before
	public void setUp() throws Exception {
		addParser = new AddCommandParser();
		editParser = new EditCommandParser();
		deleteParser = new DeleteCommandParser();
		showParser = new ShowCommandParser();
		sortParser = new SortCommandParser();
		storageParser = new StorageCommandParser();
	}


	/********************************** Test Add Command *******************************/

	/**
	 * Test standard format(add task-time-priority).
	 * @throws InvalidInputFormatException
	 */
	@Test
	public void testAdd1() throws InvalidInputFormatException {

		String testInput = "play soccer with my friend on sunday 4pm #high";

		String[] parametersActual = addParser.determineParameters(testInput);

		String[] parametersExpected = new String[5];
		parametersExpected[TASK] = "play soccer with my friend";
		parametersExpected[TIME] = parser.parse("on sunday 4pm").toString();
		parametersExpected[PRIORITY] = "high";
		parametersExpected[TYPE] = "one-time event";
		parametersExpected[STATUS] = "upcoming";

		assertArrayEquals(parametersActual, parametersExpected);

	}

	/**
	 * Test non-standard format(add time-priority-task).
	 * @throws InvalidInputFormatException
	 */
	@Test	
	public void testAdd2() throws InvalidInputFormatException {
		String testInput = "on sunday from 8am to 10am #med play soccer with my friend";

		String[] parametersActual = addParser.determineParameters(testInput);
		String[] parametersExpected = new String[5];
		parametersExpected[TASK] = "play soccer with my friend";
		parametersExpected[TIME] = parser.parse("on sunday 8am, on sunday 10am")
				.toString();
		parametersExpected[PRIORITY] = "medium";
		parametersExpected[TYPE] = "duration";
		parametersExpected[STATUS] = "upcoming";

		assertArrayEquals(parametersActual, parametersExpected);
	}

	/**
	 * Test non-standard format(add time-task).
	 * @throws InvalidInputFormatException
	 */
	@Test
	public void testAdd3() throws InvalidInputFormatException {
		String testInput = "do assignment by monday 6pm";

		String[] parametersActual = addParser.determineParameters(testInput);

		String[] parametersExpected = new String[5];
		parametersExpected[TASK] = "do assignment";
		parametersExpected[TIME] = parser.parse("by monday 6pm").toString();
		parametersExpected[PRIORITY] = "not specified";
		parametersExpected[TYPE] = "deadline";
		parametersExpected[STATUS] = "upcoming";

		assertArrayEquals(parametersActual, parametersExpected);
	}

	/**
	 * Test non-standard format(add only task).
	 * @throws InvalidInputFormatException
	 */
	@Test
	public void testAdd4() throws InvalidInputFormatException {
		String testInput = "play soccer";

		String[] parametersActual = addParser.determineParameters(testInput);

		String[] parametersExpected = new String[5];
		parametersExpected[TASK] = "play soccer";
		parametersExpected[TIME] = "[]";
		parametersExpected[PRIORITY] = "not specified";
		parametersExpected[TYPE] = "one-time event";
		parametersExpected[STATUS] = "floating";

		assertArrayEquals(parametersActual, parametersExpected);
	}

	/**
	 * Test invalid format(add priority-time).
	 */
	@Test
	public void testAdd5() {
		String testInput = "#low play soccer";
		String expectedErrorMsg = "Task name is missing!";

		try {
			addParser.determineParameters(testInput);
		} catch (InvalidInputFormatException e) {
			String actualErrorMsg = e.getMessage();
			assertEquals(actualErrorMsg, expectedErrorMsg);
		}
	}

	/**
	 * Test invalid format(add empty task).
	 */
	@Test
	public void testAdd6() {
		String testInput = "";
		String expectedErrorMsg = "Cannot add an empty task!";

		try {
			addParser.determineParameters(testInput);
		} catch (InvalidInputFormatException e) {
			String actualErrorMsg = e.getMessage();
			assertEquals(actualErrorMsg, expectedErrorMsg);
		}

	}

	/**
	 * Test invalid format(add ambiguous time).
	 */
	@Test
	public void testAdd7() {
		String testInput = "do this on mon tue 5am to 7am";
		String expectedErrorMsg = "Ambiguous time entered!";

		try {
			addParser.determineParameters(testInput);
		} catch (InvalidInputFormatException e) {
			String actualErrorMsg = e.getMessage();
			assertEquals(actualErrorMsg, expectedErrorMsg);
		}

	}


	/********************************** Test Edit Command *****************************/

	/**
	 * Test editing task name(edit all fields).
	 * @throws InvalidInputFormatException
	 */
	@Test
	public void testEdit1() throws InvalidInputFormatException {

		String testInput = "do laundry from 6pm to 8pm #low, "
				+ "play soccer with my friend on sunday 10am  #high";

		String[] parametersActual = editParser.determineParameters(testInput);
		String[] parametersExpected = new String[5];
		parametersExpected[TASK] = "do laundry , play soccer with my friend";
		parametersExpected[TIME] = parser.parse("from 6pm to 8pm").toString()
				+ " , " +parser.parse("on sun 10am").toString();
		parametersExpected[PRIORITY] = "low , high";
		parametersExpected[TYPE] = "duration , one-time event";
		parametersExpected[STATUS] = "upcoming , upcoming";

		assertArrayEquals(parametersActual, parametersExpected);

	}

	/**
	 * Test not editing task name(edit priority only).
	 * @throws InvalidInputFormatException
	 */
	@Test
	public void testEdit2() throws InvalidInputFormatException {
		String testInput = "do laundry , #high";

		String[] parametersActual = editParser.determineParameters(testInput);
		String[] parametersExpected = new String[5];
		parametersExpected[TASK] = "do laundry , do laundry";
		parametersExpected[TIME] = "[] , []";
		parametersExpected[PRIORITY] = "not specified , high";
		parametersExpected[TYPE] = "one-time event , one-time event";
		parametersExpected[STATUS] = "floating , floating";

		assertArrayEquals(parametersActual, parametersExpected);
	}

	/**
	 * Test not editing task name(edit time only).
	 * @throws InvalidInputFormatException
	 */
	@Test
	public void testEdit3() throws InvalidInputFormatException {
		String testInput = "do laundry from 6pm to 8pm, "
				+ "on sunday 10am";

		String[] parametersActual = editParser.determineParameters(testInput);

		String[] parametersExpected = new String[5];
		parametersExpected[TASK] = "do laundry , do laundry";
		parametersExpected[TIME] = parser.parse("from 6pm to 8pm").toString()
				+ " , " + parser.parse("on sunday 10am").toString();
		parametersExpected[PRIORITY] = "not specified , not specified";
		parametersExpected[TYPE] = "duration , one-time event";
		parametersExpected[STATUS] = "upcoming , upcoming";

		assertArrayEquals(parametersActual, parametersExpected);
	}


	/**
	 * Test not editing task name(edit time and priority).
	 * @throws InvalidInputFormatException
	 */
	@Test
	public void testEdit4() throws InvalidInputFormatException {
		String testInput = "do laundry from 6pm to 8pm, "
				+ "on sunday 10am #high";

		String[] parametersActual = editParser.determineParameters(testInput);

		String[] parametersExpected = new String[5];
		parametersExpected[TASK] = "do laundry , do laundry";
		parametersExpected[TIME] = parser.parse("from 6pm to 8pm").toString()
				+ " , " + parser.parse("on sunday 10am").toString();
		parametersExpected[PRIORITY] = "not specified , high";
		parametersExpected[TYPE] = "duration , one-time event";
		parametersExpected[STATUS] = "upcoming , upcoming";

		assertArrayEquals(parametersActual, parametersExpected);
	}

	/**
	 * Test invalid editing(no original task name).
	 */
	@Test
	public void testEdit5() {
		String testInput = ", play soccer with my friend on sunday 10am #high";
		String expectedErrorMsg = "Please specify a task to be edited!";

		try {
			editParser.determineParameters(testInput);
		} catch (InvalidInputFormatException e) {
			String actualErrorMsg = e.getMessage();
			assertEquals(actualErrorMsg, expectedErrorMsg);
		}	

	}

	/**
	 * Test invalid editing(no comma).
	 */
	@Test
	public void testEdit6() {
		String testInput = "watch TV -> play soccer with my friend";
		String expectedErrorMsg = "Please use \",\" to separate!";

		try {
			editParser.determineParameters(testInput);
		} catch (InvalidInputFormatException e) {
			String actualErrorMsg = e.getMessage();
			assertEquals(actualErrorMsg, expectedErrorMsg);
		}	

	}

	/**
	 * Test invalid editing format(no update information).
	 */
	@Test
	public void testEdit7() {
		String testInput = "do this, ";
		String expectedErrorMsg = "Please specifiy update information!";

		try {
			editParser.determineParameters(testInput);
		} catch (InvalidInputFormatException e) {
			String actualErrorMsg = e.getMessage();
			assertEquals(actualErrorMsg, expectedErrorMsg);
		}	

	}


	/********************************** Test Delete Command ****************************/

	/**
	 * Test valid deleting.
	 * @throws InvalidInputFormatException
	 */
	@Test
	public void testDelete1() throws InvalidInputFormatException {
		String testInput = "play soccer";

		String[] parametersActual = deleteParser.determineParameters(testInput);

		String[] parametersExpected = new String[5];
		parametersExpected[TASK] = testInput;

		assertArrayEquals(parametersActual, parametersExpected);	
	}

	/**
	 * Test invalid deleting(edit nothing).
	 */
	@Test
	public void testDelete2() {
		String testInput = "";
		String expectedErrorMsg = "Please specify a task to delete!";

		try {
			deleteParser.determineParameters(testInput);
		} catch (InvalidInputFormatException e) {
			String actualErrorMsg = e.getMessage();
			assertEquals(actualErrorMsg, expectedErrorMsg);
		}	
	}


	/********************************** Test Show Command *****************************/

	/**
	 * Test show by "priority high".
	 * @throws InvalidInputFormatException
	 */
	@Test
	public void testShow1() throws InvalidInputFormatException {
		String testInput = "high";

		String[] parametersActual = showParser.determineParameters(testInput);

		String[] parametersExpected = new String[5];
		parametersExpected[PRIORITY] = testInput;

		assertArrayEquals(parametersActual, parametersExpected);	
	}

	/**
	 * Test show by "priority medium".
	 * throws InvalidInputFormatException
	 */
	@Test
	public void testShow2() throws InvalidInputFormatException {
		String testInput = "medium";

		String[] parametersActual = showParser.determineParameters(testInput);

		String[] parametersExpected = new String[5];
		parametersExpected[PRIORITY] = testInput;

		assertArrayEquals(parametersActual, parametersExpected);		
	}

	/**
	 * Test show by "priority low".
	 * @throws InvalidInputFormatException
	 */
	@Test
	public void testShow3() throws InvalidInputFormatException {
		String testInput = "low";

		String[] parametersActual = showParser.determineParameters(testInput);

		String[] parametersExpected = new String[5];
		parametersExpected[PRIORITY] = testInput;

		assertArrayEquals(parametersActual, parametersExpected);		
	}

	/**
	 * Test show by time.
	 */
	@Test
	public void testShow4() throws InvalidInputFormatException {
		String testInput = "monday";

		String[] parametersActual = showParser.determineParameters(testInput);

		String[] parametersExpected = new String[5];
		parametersExpected[TIME] = parser.parse(testInput).toString();

		assertArrayEquals(parametersActual, parametersExpected);		
	}

	/**
	 * Test invalid showing(by nothing).
	 */
	@Test
	public void testShow5() {
		String testInput = "";
		String expectedErrorMsg = "Please specify a filter for show command!";

		try {
			showParser.determineParameters(testInput);
		} catch (InvalidInputFormatException e) {
			String actualErrorMsg = e.getMessage();
			assertEquals(actualErrorMsg, expectedErrorMsg);
		}	
	}

	/**
	 * Test invalid showing(by invalid filter).
	 */
	@Test
	public void testShow6() {
		String testInput = "do homework";
		String expectedErrorMsg = "Please choose a valid filter!";

		try {
			showParser.determineParameters(testInput);
		} catch (InvalidInputFormatException e) {
			String actualErrorMsg = e.getMessage();
			assertEquals(actualErrorMsg, expectedErrorMsg);
		}	
	}

	/********************************** Test Sort Command *****************************/

	/**
	 * Test sort by priority.
	 * @throws InvalidInputFormatException
	 */
	@Test
	public void testSort1() throws InvalidInputFormatException {
		String testInput = "priority";

		String[] parametersActual = sortParser.determineParameters(testInput);

		String[] parametersExpected = new String[5];
		parametersExpected[TASK] = testInput;

		assertArrayEquals(parametersActual, parametersExpected);	
	}

	/**
	 * Test sort by time.
	 * @throws InvalidInputFormatException
	 */
	@Test
	public void testSort2() throws InvalidInputFormatException {
		String testInput = "time";

		String[] parametersActual = sortParser.determineParameters(testInput);

		String[] parametersExpected = new String[5];
		parametersExpected[TASK] = testInput;

		assertArrayEquals(parametersActual, parametersExpected);	
	}

	/**
	 * Test sort by name.
	 * @throws InvalidInputFormatException
	 */
	@Test
	public void testSort3() throws InvalidInputFormatException {
		String testInput = "name";

		String[] parametersActual = sortParser.determineParameters(testInput);

		String[] parametersExpected = new String[5];
		parametersExpected[TASK] = testInput;

		assertArrayEquals(parametersActual, parametersExpected);	
	}

	/**
	 * Test invalid sorting(by invalid parameter).
	 */
	@Test
	public void testSort4() {
		String testInput = "play";
		String expectedErrorMsg = "Sort by \"name\", \"time\" or \"priority\" only!";

		try {
			sortParser.determineParameters(testInput);
		} catch (InvalidInputFormatException e) {
			String actualErrorMsg = e.getMessage();
			assertEquals(actualErrorMsg, expectedErrorMsg);
		}	
	}

	/**
	 * Test invalid sorting(no parameter).
	 */
	@Test
	public void testSort5() {
		String testInput = "";
		String expectedErrorMsg = "Please specify a parameter for sorting!";

		try {
			sortParser.determineParameters(testInput);
		} catch (InvalidInputFormatException e) {
			String actualErrorMsg = e.getMessage();
			assertEquals(actualErrorMsg, expectedErrorMsg);
		}	
	}


	/********************************** Test Storage Command ***************************/

	/**
	 * Test valid storage command(valid path).
	 * @throws InvalidInputFormatException
	 * @throws NoFileNameException 
	 * @throws InvalidPathException 
	 */
	@Test
	public void testStorageCommand1() throws InvalidInputFormatException, 
	InvalidPathException, NoFileNameException {
		String testInput = "C:/mytext";

		String[] parametersActual = storageParser.determineParameters(
				CommandType.SAVE, testInput);

		String[] parametersExpected = new String[5];
		parametersExpected[TASK] = testInput + ".txt";

		assertArrayEquals(parametersActual, parametersExpected);	
	}

	/**
	 * Test invalid storage command(invalid path case 1).
	 */
	@Test
	public void testStorageCommand2() {
		String testInput = "C:/Documents and Settings/";
		String expectedErrorMsg = "No file name is entered!";

		try {
			storageParser.determineParameters(CommandType.MOVE, testInput);
		} catch (InvalidPathException e) {
			String actualErrorMsg = e.getMessage();
			assertEquals(actualErrorMsg, expectedErrorMsg);
		} catch (InvalidInputFormatException e) {
			String actualErrorMsg = e.getMessage();
			assertEquals(actualErrorMsg, expectedErrorMsg);
		} catch (NoFileNameException e) {
			String actualErrorMsg = e.getMessage();
			assertEquals(actualErrorMsg, expectedErrorMsg);
		}
	}
	
	/**
	 * Test invalid storage command(invalid path case 2).
	 */
	@Test
	public void testStorageCommand3() {
		String testInput = "";
		String expectedErrorMsg = "Please enter a non-empty path!";

		try {
			storageParser.determineParameters(CommandType.MOVE, testInput);
		} catch (InvalidPathException e) {
			String actualErrorMsg = e.getMessage();
			assertEquals(actualErrorMsg, expectedErrorMsg);
		} catch (InvalidInputFormatException e) {
			String actualErrorMsg = e.getMessage();
			assertEquals(actualErrorMsg, expectedErrorMsg);
		} catch (NoFileNameException e) {
			String actualErrorMsg = e.getMessage();
			assertEquals(actualErrorMsg, expectedErrorMsg);
		}
	}
	
	/**
	 * Test invalid storage command(invalid path case 3).
	 */
	@Test
	public void testStorageCommand4() {
		String testInput = "test??test!!test##";
		String expectedErrorMsg = "Invalid path is entered!: test??test!!test##";

		try {
			storageParser.determineParameters(CommandType.MOVE, testInput);
		} catch (InvalidPathException e) {
			String actualErrorMsg = e.getMessage();
			assertEquals(actualErrorMsg, expectedErrorMsg);
		} catch (InvalidInputFormatException e) {
			String actualErrorMsg = e.getMessage();
			assertEquals(actualErrorMsg, expectedErrorMsg);
		} catch (NoFileNameException e) {
			String actualErrorMsg = e.getMessage();
			assertEquals(actualErrorMsg, expectedErrorMsg);
		}
	}

}
```
###### main\java\parser\ParserTest.java
``` java

```
###### main\java\parser\ShowCommandParser.java
``` java
package main.java.parser;

import java.util.Date;
import java.util.List;

import org.ocpsoft.prettytime.nlp.PrettyTimeParser;

import main.java.enumeration.PriorityLevel;
import main.java.exception.InvalidInputFormatException;

/**
 * This class parses the show command.
 * @author Ouyang Danwen
 *
 */
public class ShowCommandParser {
	
	/* error messages used in this class */
	private static final String ERORR_MESSAGE_SHOW_NOTHING = ""
			+ "Please specify a filter for show command!";
	private static final String ERROR_MESSAGE_INVALID_FILTER = ""
			+ "Please choose a valid filter!";
	
	/* string constants used in this class */
	private static final String PRIORITY_HIGH_ALIAS = "h";
	private static final String PRIORITY_MEDIUM_ALIAS_1 = "med";
	private static final String PRIORITY_MEDIUM_ALIAS_2 = "m";
	private static final String PRIORITY_LOW_ALIAS = "l";
	private static final String TOMORROW_IN_FULL = "tomorrow";
	private static final String TOMORROW_IN_SHORT = "tmr";
	
	/* numeric indices to access the parameters array */
	private static final int TIME = 1;
	private static final int PRIORITY = 2;
	
	/**
	 * Empty constructor.
	 */
	public ShowCommandParser() {}

	/**
	 * @param commandContent
	 * @return the command parameters as a string array
	 * @throws InvalidInputFormatException
	 */
	public String[] determineParameters(String commandContent) throws InvalidInputFormatException {
		assert commandContent != null;
		
		String[] parameters = new String[5];
		if (commandContent.isEmpty()) {
			throw new InvalidInputFormatException(ERORR_MESSAGE_SHOW_NOTHING);
		}
		
		else {
			setShowFiterIfApplicable(parameters, commandContent);
		}
		
		return parameters;
	}

	/**
	 * Determine and set the filter for show command.
	 * Only valid filters will be allowed.
	 * @param parameters
	 * @param commandContent
	 * @throws InvalidInputFormatException
	 */
	private void setShowFiterIfApplicable(String[] parameters, String commandContent) 
			throws InvalidInputFormatException {
		assert parameters != null;
		assert commandContent != null;
		
		commandContent = commandContent.toLowerCase();
		commandContent = commandContent.replaceAll(TOMORROW_IN_SHORT, TOMORROW_IN_FULL);
		PrettyTimeParser timeParser = new PrettyTimeParser();
		List<Date> dates = timeParser.parse(commandContent);
		
		if (dates.size() == 1) {
			parameters[TIME] = dates.toString();
		}
		else if (commandContent.equals(PRIORITY_HIGH_ALIAS) 
				|| commandContent.equals(PriorityLevel.HIGH.getType())) {
			parameters[PRIORITY] = PriorityLevel.HIGH.getType();
			
		}
		else if (commandContent.equals(PRIORITY_MEDIUM_ALIAS_1) 
				|| commandContent.equals(PRIORITY_MEDIUM_ALIAS_2) 
				|| commandContent.equals(PriorityLevel.MEDIUM.getType())) {
			parameters[PRIORITY] = PriorityLevel.MEDIUM.getType();
		}
		
		else if (commandContent.equals(PriorityLevel.LOW.getType()) 
				|| commandContent.equals(PRIORITY_LOW_ALIAS)) {
			parameters[PRIORITY] = PriorityLevel.LOW.getType();
		}
		
		else {
			throw new InvalidInputFormatException(ERROR_MESSAGE_INVALID_FILTER);
		}
		
	}

}
```
###### main\java\parser\ShowCommandParser.java
``` java

```
###### main\java\parser\SortCommandParser.java
``` java
package main.java.parser;

import main.java.exception.InvalidInputFormatException;

/**
 * This class parses the sort command.
 * @author Ouyang Danwen
 *
 */
public class SortCommandParser {

	/* error messages used in this class */
	private static final String ERROR_MESSAGE_SORT_BY_NOTHING = ""
			+ "Please specify a parameter for sorting!";
	private static final String EORROR_MESSAGE_INVALID_SORTING_PARAMETER = ""
			+ "Sort by \"name\", \"time\" or \"priority\" only!";
	
	/* string constants used in this class */
	private static final String STRING_TIME = "time";
	private static final String STRING_PRIORITY = "priority";
	private static final String STRING_NAME = "name";
	
	/* numeric indices to access the parameters array */
	private static final int TASK = 0;


	/**
	 * Empty constructor.
	 */
	public SortCommandParser() {}

	/**
	 * @param commandContent
	 * @return the command parameters as a string array
	 * @throws InvalidInputFormatException
	 */
	public String[] determineParameters(String commandContent) 
			throws InvalidInputFormatException {
		assert commandContent != null;

		String[] parameters = new String[5];

		//command content is empty
		if (commandContent.isEmpty()) {
			throw new InvalidInputFormatException(ERROR_MESSAGE_SORT_BY_NOTHING);
		}
		
		//command content is not empty
		else {
			String parameter = commandContent.toLowerCase();

			if (parameter.equals(STRING_TIME) || parameter.equals(STRING_NAME) ||
					parameter.equals(STRING_PRIORITY)) {
				parameters[TASK] = commandContent;
			}

			else {
				throw new InvalidInputFormatException(
						EORROR_MESSAGE_INVALID_SORTING_PARAMETER);
			}
		}

		return parameters;
	}

}
```
###### main\java\parser\SortCommandParser.java
``` java

```
###### main\java\parser\StorageCommandParser.java
``` java
package main.java.parser;

import java.nio.file.InvalidPathException;

import main.java.enumeration.CommandType;
import main.java.exception.InvalidInputFormatException;
import main.java.exception.NoFileNameException;

/**
 * This parser parses storage related commands including "move", "save" and "open".
 * @author Ouyang Danwen
 *
 */
public class StorageCommandParser {
	
	/* error messages used in this class */
	private static final String ERROR_MESSAGE_EMPTY_PATH = "Please enter a non-empty path!";
	private static final String ERROR_NO_FILE_NAME = "No file name is entered!";
	private static final String ERROR_INVALID_PATH = "Invalid path is entered!";
	
	/* numeric indices to access parameters array */
	private static final int TASK = 0;
	
	/**
	 * Empty constructor.
	 */
	public StorageCommandParser() {}

	/**
	 * @param commandType
	 * @param commandContent
	 * @return the command parameters as a string array
	 * @throws InvalidInputFormatException
	 * @throws NoFileNameException 
	 */
	public String[] determineParameters(CommandType commandType, String commandContent) 
			throws InvalidInputFormatException, NoFileNameException, InvalidPathException {
		assert commandType != null;
		assert commandContent != null;

		String[] parameters = new String[5];
		
		if (commandContent.isEmpty()) {
			throw new InvalidInputFormatException(ERROR_MESSAGE_EMPTY_PATH);
		}

		else {
			String path = commandContent;
			parameters[TASK] = validifyPath(path);
		}

		return parameters;
	}

	/**
	 * Check the validity of the path.
	 * Return the validified path or throw exceptions otherwise.
	 * @param path
	 * @return the validified path
	 * @throws NoFileNameException
	 * @throws InvalidPathException
	 */
	private String validifyPath(String path) throws NoFileNameException, 
	InvalidPathException {
		assert path != null;
		
		//append the file type for user
		if (!path.endsWith(".txt") && !path.endsWith("/") 
				&& Character.isLetter(path.charAt(path.length()-1))) {
			path = path.concat(".txt");
			return path;
		} 
		
		//append the file type for user
		else if (path.endsWith(".")) {
			path = path.concat("txt");
			return path;
		} 
		
		//invalid file ending
		else if (path.endsWith("/")) {
			throw new NoFileNameException(ERROR_NO_FILE_NAME);
		} 
		
		else if (path.endsWith("txt")) {
			return path;
		}
		
		//invalid path in general
		else {
			throw new InvalidPathException(path, ERROR_INVALID_PATH);
		}
	}

}
```
###### main\java\parser\StorageCommandParser.java
``` java

```
